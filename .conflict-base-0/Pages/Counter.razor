@page "/counter"
@inject IJSRuntime JS

<PageTitle>Block Drag Test</PageTitle>

<h1>Blocks (drag them)</h1>

<div class="stage" @ref="stageRef"
     @onpointermove="OnStagePointerMove"
     @onpointerup="OnStagePointerUp"
     @onpointercancel="OnStagePointerUp">

    <div class="fixed"
         style="left:@($"{fixedX}px"); top:@($"{fixedY}px");">
        <svg width="90" height="90" viewBox="0 0 92 92">
            <path d="
                M 1 1
                L 15 1
                L 15 15
                L 30 1
                L 91 1
                L 91 75
                L 30 75
                L 15 91
                L 15 75
                L 1 75
                Z"
                  fill="#FFA500"
                  stroke="#000000"
                  stroke-width="1" />
        </svg>
    </div>

    @if (hoverActive)
    {
        <div class="ghost"
             style="left:@($"{hoverX}px"); top:@($"{hoverY}px");">
            <svg width="90" height="90" viewBox="0 0 92 92">
                <path d="
                    M 1 1
                    L 15 1
                    L 15 15
                    L 30 1
                    L 91 1
                    L 91 75
                    L 30 75
                    L 15 91
                    L 15 75
                    L 1 75
                    Z"
                      fill="transparent"
                      stroke="#000000"
                      stroke-width="3" />
            </svg>
        </div>
    }

    @foreach (var b in blocks)
    {
        <div class="draggable @(b.Locked ? "locked" : "")"
             style="left:@($"{b.X}px"); top:@($"{b.Y}px");"
             @onpointerdown="(e) => OnBlockPointerDown(e, b.Id)">
            <svg width="90" height="90" viewBox="0 0 92 92">
                <path d="
                    M 1 1
                    L 15 1
                    L 15 15
                    L 30 1
                    L 91 1
                    L 91 75
                    L 30 75
                    L 15 91
                    L 15 75
                    L 1 75
                    Z"
                      fill="#FFA500"
                      stroke="#000000"
                      stroke-width="1" />
            </svg>
        </div>
    }
</div>

<style>
    .stage {
        position: relative;
        height: 70vh;
        border: 1px solid #ccc;
        user-select: none;
        touch-action: none;
        overflow: hidden;
    }

    .draggable {
        position: absolute;
        cursor: grab;
        touch-action: none;
        z-index: 2;
    }

    .draggable:active {
        cursor: grabbing;
    }

    .draggable.locked {
        cursor: not-allowed;
        opacity: 0.95;
    }

    .fixed {
        position: absolute;
        pointer-events: none;
        z-index: 1;
    }

    .ghost {
        position: absolute;
        pointer-events: none;
        opacity: 0.9;
        z-index: 0;
    }
</style>

<script>
    window.blockDrag = {
        rect: (el) => {
            const r = el.getBoundingClientRect();
            return { left: r.left, top: r.top };
        }
    };
</script>

@code {
    private ElementReference stageRef;

    private double fixedX = 40;
    private double fixedY = 40;

    private List<Block> blocks = new() {
        new Block(1, 180, 40, false, null),
        new Block(2, 280, 40, false, null)
    };

    private int? activeId = null;
    private bool dragging = false;
    private bool activeWasLockedAtDown = false;
    private double grabOffsetX = 0;
    private double grabOffsetY = 0;
    private double stageLeft = 0;
    private double stageTop = 0;

    private bool hoverActive = false;
    private double hoverX = 0;
    private double hoverY = 0;

    private const double StackStepY = 71;

    private async Task OnBlockPointerDown(PointerEventArgs e, int id) {
        activeId = id;
        dragging = true;

        var bottomLockedId = BottomLockedIdExcluding(null);
        var selected = blocks.First(x => x.Id == id);

        if (selected.Locked && selected.Id != bottomLockedId) {
            activeId = null;
            dragging = false;
            return;
        }

        activeWasLockedAtDown = selected.Locked;

        if (selected.Locked) {
           var idx = blocks.FindIndex(x => x.Id == id);
            selected = selected with { Locked = false };  
            blocks[idx] = selected;
        }

        var stageRect = await JS.InvokeAsync<Rect>("blockDrag.rect", stageRef);
        stageLeft = stageRect.Left;
        stageTop = stageRect.Top;

        var b = blocks.First(x => x.Id == id);

        grabOffsetX = e.ClientX - (stageLeft + b.X);
        grabOffsetY = e.ClientY - (stageTop + b.Y);

        UpdateHoverPreview(b);
    }

    private void OnStagePointerMove(PointerEventArgs e) {
        if (!dragging || activeId is null) return;

        var idx = blocks.FindIndex(x => x.Id == activeId.Value);
        if (idx < 0) return;

        var b = blocks[idx];

        b.X = Math.Round(e.ClientX - stageLeft - grabOffsetX);
        b.Y = Math.Round(e.ClientY - stageTop - grabOffsetY);

        blocks[idx] = b;

        UpdateHoverPreview(b);
    }

    private void OnStagePointerUp(PointerEventArgs e) {

        if (!dragging || activeId is null) return;

        var idx = blocks.FindIndex(x => x.Id == activeId.Value);
        if (idx >= 0) {
        var b = blocks[idx];

        if (hoverActive) {

            b = b with {
                X = hoverX,
                Y = hoverY,
                Locked = true,
                ParentId = hoverAnchorId
        };
        }
        else {

            if (activeWasLockedAtDown)
                b = b with { Locked = false, ParentId = null };
            }

            blocks[idx] = b;
        }

        dragging = false;
        activeId = null;
        hoverActive = false;
        activeWasLockedAtDown = false;
        hoverAnchorId = null;
    }

    private int? hoverAnchorId = null;

    private void UpdateHoverPreview(Block dragged) {

        hoverAnchorId = BottomLockedIdExcluding(activeId);

        double anchorX, anchorY;

        if (hoverAnchorId is null) {
            anchorX = fixedX;
            anchorY = fixedY;
        }
        else {
            var anchor = blocks.First(b => b.Id == hoverAnchorId.Value);
            anchorX = anchor.X;
            anchorY = anchor.Y;
        }

        var targetX = anchorX;
        var targetY = anchorY + StackStepY;

        double zoneLeft = anchorX - 45;
        double zoneRight = anchorX + 45;
        double zoneTop = anchorY + 60;
        double zoneBottom = anchorY + 120;

        bool inside =
            dragged.X >= zoneLeft &&
            dragged.X <= zoneRight &&
            dragged.Y >= zoneTop &&
            dragged.Y <= zoneBottom;

        hoverActive = inside;

        if (hoverActive){
            hoverX = targetX;
            hoverY = targetY;
        }
    }

    private int? BottomLockedIdExcluding(int? excludeId) {
        var locked = blocks
            .Where(b => b.Locked && b.Id != excludeId)
            .OrderByDescending(b => b.Y)
            .FirstOrDefault();

        return blocks.Any(b => b.Locked && b.Id != excludeId) ? locked.Id : (int?)null;
    }

    private record Rect(double Left, double Top);
    private record struct Block(int Id, double X, double Y, bool Locked, int? ParentId);
}