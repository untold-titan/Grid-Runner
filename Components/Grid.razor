@{
    var (prefix, _, cellSizePx, cols) = GetGridRenderInfo();
    var (exitRow, exitCol) = GetExitRowCol(prefix);
    string exitClass = ExitSide.HasValue ? $"exit-{ExitSide.Value}" : "";

    string gridStyle =
        $"--cell-size:{cellSizePx}px;" +
        $"--cols:{cols};" +
        $"--exit-row:{exitRow};" +
        $"--exit-col:{exitCol};" +
        $"display:grid; grid-template-columns:repeat({cols},{cellSizePx}px);" +
        $"grid-auto-rows:{cellSizePx}px;";
}

<div class="grid-container @GridCssClass @exitClass" style="@gridStyle">
    @RenderGrid()
</div>

<style>
    .grid-container {
        width: fit-content;
        position: relative;
        gap: 0;
        border: 1px solid #000;
        background: white;
        box-sizing: border-box;
    }

    .cell {
        border: 1px solid #333;
        background-color: #a1e9ed;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        position: relative;
        user-select: none;
        box-sizing: border-box;
        cursor: pointer;
    }

    .cell.selected {
        outline: 4px solid rgba(0,0,0,0.55);
        outline-offset: -4px;
    }

    .occupied.veh-red { background-color: #ff6b6b; }
    .occupied.veh-green { background-color: #5fe37a; }
    .occupied.veh-blue { background-color: #6ea8fe; }
    .occupied.veh-yellow { background-color: #ffe066; }

    .veh-label {
        position: absolute;
        bottom: 3px;
        right: 5px;
        font-size: 12px;
        opacity: 0.9;
        pointer-events: none;
    }

    .cell.exit.exit-A { border-left-color: white; }
    .cell.exit.exit-B { border-top-color: white; }
    .cell.exit.exit-C { border-right-color: white; }
    .cell.exit.exit-D { border-bottom-color: white; }

    .grid-container.exit-B::before,
    .grid-container.exit-D::before {
        content: "";
        position: absolute;
        left: calc(var(--exit-col) * var(--cell-size));
        width: var(--cell-size);
        height: 4px;
        background: white;
        pointer-events: none;
        z-index: 10;
    }

    .grid-container.exit-B::before { top: -2px; }
    .grid-container.exit-D::before { bottom: -2px; }

    .grid-container.exit-A::before,
    .grid-container.exit-C::before {
        content: "";
        position: absolute;
        top: calc(var(--exit-row) * var(--cell-size));
        height: var(--cell-size);
        width: 4px;
        background: white;
        pointer-events: none;
        z-index: 10;
    }

    .grid-container.exit-A::before { left: -2px; }
    .grid-container.exit-C::before { right: -2px; }
</style>

@code {
    [Parameter] public string Difficulty { get; set; } = "Easy";
    [Parameter] public EventCallback<string> OnStatusChanged { get; set; }
    [Parameter] public EventCallback<bool> OnGameWonChanged { get; set; }

    private char? ExitSide;
    private string? ExitCellKey;
    private readonly List<Vehicle> Vehicles = new();
    private int? SelectedVehicleIndex;
    private bool GameWon = false;

    private readonly List<string> EasyCells = BuildCells(4, 4);
    private readonly List<string> MediumCells = BuildCells(5, 5);
    private readonly List<string> HardCells = BuildCells(6, 6);

    public bool HasSelection => SelectedVehicleIndex.HasValue && SelectedVehicleIndex.Value >= 0 && SelectedVehicleIndex.Value < Vehicles.Count;

    public string SelectedVehicleDisplay => HasSelection
        ? $"{Vehicles[SelectedVehicleIndex!.Value].Type} ({Vehicles[SelectedVehicleIndex!.Value].Color})"
        : "(none)";

    public bool IsGameWon => GameWon;

    private string GridCssClass => Difficulty switch
    {
        "Easy" => "easy",
        "Medium" => "medium",
        "Hard" => "hard",
        _ => "easy"
    };

    // Public methods for vehicle movement
    public void MoveSelectedLeft() => MoveSelected(dx: -1, dy: 0);
    public void MoveSelectedRight() => MoveSelected(dx: +1, dy: 0);
    public void MoveSelectedUp() => MoveSelected(dx: 0, dy: -1);
    public void MoveSelectedDown() => MoveSelected(dx: 0, dy: +1);
    public void RotateSelectedCounterClockwise() => RotateSelected(isClockwise: false);
    public void RotateSelectedClockwise() => RotateSelected(isClockwise: true);

    public void LoadLevelLine(string line)
    {
        try
        {
            Vehicles.Clear();
            ExitSide = null;
            ExitCellKey = null;
            SelectedVehicleIndex = null;
            GameWon = false;

            var parts = line.Split(';', StringSplitOptions.RemoveEmptyEntries)
                            .Select(p => p.Trim())
                            .ToArray();

            if (parts.Length < 2)
            {
                UpdateStatus("Invalid level line: expected Side,Cell;vehicle;vehicle;...");
                return;
            }

            var (prefix, validCells, _, _) = GetGridRenderInfo();

            var exitTokens = parts[0].Split(',', StringSplitOptions.RemoveEmptyEntries)
                                     .Select(t => t.Trim())
                                     .ToArray();

            if (exitTokens.Length != 2)
            {
                UpdateStatus("Exit must be in format: Side,Cell (ex: A,1A)");
                return;
            }

            ExitSide = char.ToUpperInvariant(exitTokens[0][0]);
            string exitCellLabel = exitTokens[1].ToUpper();

            if (!validCells.Contains(exitCellLabel))
            {
                UpdateStatus($"Exit cell '{exitCellLabel}' is not valid for {Difficulty}.");
                return;
            }

            ExitCellKey = prefix + exitCellLabel;

            for (int p = 1; p < parts.Length; p++)
            {
                var tokens = parts[p].Split(',', StringSplitOptions.RemoveEmptyEntries)
                                     .Select(t => t.Trim())
                                     .ToArray();

                if (tokens.Length != 4)
                {
                    UpdateStatus($"Vehicle section must be exactly 4 tokens: Type,Color,Start,End. Bad section: '{parts[p]}'");
                    return;
                }

                char type = ParseType(tokens[0]);
                char color = ParseColor(tokens[1]);
                string start = tokens[2].ToUpper();
                string end = tokens[3].ToUpper();

                if (!validCells.Contains(start) || !validCells.Contains(end))
                {
                    UpdateStatus($"Vehicle has invalid start/end cell: {start} -> {end}.");
                    return;
                }

                var occupiedLabels = BuildOccupiedCellsFromStartEnd(start, end);
                if (occupiedLabels == null || occupiedLabels.Count == 0)
                {
                    UpdateStatus($"Vehicle start/end must be in same row or same column: {start} -> {end}.");
                    return;
                }

                int expectedLen = ExpectedLength(type);
                if (expectedLen > 0 && occupiedLabels.Count != expectedLen)
                {
                    UpdateStatus($"Vehicle {type} expected length {expectedLen} but got {occupiedLabels.Count} from {start}->{end}.");
                    return;
                }

                var occupiedKeys = occupiedLabels.Select(lbl => prefix + lbl).ToList();

                var allOccupied = Vehicles.SelectMany(v => v.Cells).ToHashSet();
                if (occupiedKeys.Any(allOccupied.Contains))
                {
                    UpdateStatus($"Collision: vehicle {type} overlaps an existing vehicle.");
                    return;
                }

                Vehicles.Add(new Vehicle
                {
                    Type = type,
                    Color = color,
                    CssClass = CssClassForColor(color),
                    Cells = occupiedKeys
                });
            }

            UpdateStatus($"Loaded level: vehicles={Vehicles.Count}.");
        }
        catch (Exception ex)
        {
            UpdateStatus($"Parse error: {ex.Message}");
        }
    }

    public void ClearLevel()
    {
        Vehicles.Clear();
        ExitSide = null;
        ExitCellKey = null;
        SelectedVehicleIndex = null;
        GameWon = false;
        UpdateStatus("Cleared.");
        NotifyGameWonChanged(false);
    }

    private void SelectVehicleAtCell(string cellKey)
    {
        if (GameWon) return;

        for (int i = 0; i < Vehicles.Count; i++)
        {
            if (Vehicles[i].Cells.Contains(cellKey))
            {
                SelectedVehicleIndex = i;
                UpdateStatus($"Selected: {Vehicles[i].Type} ({Vehicles[i].Color})");
                return;
            }
        }

        SelectedVehicleIndex = null;
        UpdateStatus("Selected: (none)");
    }

    private void MoveSelected(int dx, int dy)
    {
        if (!HasSelection || GameWon) return;

        var (prefix, validCells, _, _) = GetGridRenderInfo();
        var v = Vehicles[SelectedVehicleIndex!.Value];

        var labels = v.Cells.Select(k => StripPrefix(k, prefix)).ToList();
        var orientation = GetOrientation(labels);

        if (orientation == Orientation.Horizontal && dy != 0)
        {
            UpdateStatus("Blocked: horizontal vehicles can only move left/right.");
            return;
        }

        if (orientation == Orientation.Vertical && dx != 0)
        {
            UpdateStatus("Blocked: vertical vehicles can only move up/down.");
            return;
        }

        bool anyOutOfBounds = false;
        var movedLabels = new List<string>(labels.Count);

        foreach (var lbl in labels)
        {
            var (r, c) = ParseCell(lbl);
            int nr = r + dy;
            int nc = c + dx;
            var newLbl = ToCell(nr, nc);

            if (!validCells.Contains(newLbl))
                anyOutOfBounds = true;

            movedLabels.Add(newLbl);
        }

        if (anyOutOfBounds)
        {
            if (TryWinByExiting(v, labels, dx, dy, prefix))
            {
                GameWon = true;
                UpdateStatus("You win! Press Play Again to reset.");
                NotifyGameWonChanged(true);
                SelectedVehicleIndex = null;
                return;
            }

            UpdateStatus("Blocked: out of bounds.");
            return;
        }

        var movedKeys = movedLabels.Select(l => prefix + l).ToList();

        if (!IsMoveCollisionFree(SelectedVehicleIndex.Value, movedKeys))
        {
            UpdateStatus("Blocked: another vehicle is in the way.");
            return;
        }

        v.Cells = movedKeys;
        UpdateStatus("Moved.");
    }

    private bool TryWinByExiting(Vehicle v, List<string> currentLabels, int dx, int dy, string prefix)
    {
        if (v.Type != 'P') return false;
        if (!ExitSide.HasValue || ExitCellKey == null) return false;

        bool movingOut =
            (ExitSide.Value == 'A' && dx == -1 && dy == 0) ||
            (ExitSide.Value == 'C' && dx == +1 && dy == 0) ||
            (ExitSide.Value == 'B' && dx == 0 && dy == -1) ||
            (ExitSide.Value == 'D' && dx == 0 && dy == +1);

        if (!movingOut) return false;

        var orientation = GetOrientation(currentLabels);
        bool orientedForExit =
            ((ExitSide.Value == 'A' || ExitSide.Value == 'C') && orientation == Orientation.Horizontal) ||
            ((ExitSide.Value == 'B' || ExitSide.Value == 'D') && orientation == Orientation.Vertical);

        if (!orientedForExit) return false;

        string exitLabel = StripPrefix(ExitCellKey, prefix);
        if (!currentLabels.Contains(exitLabel)) return false;

        string edgeMost = GetEdgeMostCellInDirection(currentLabels, dx, dy);
        if (edgeMost != exitLabel) return false;

        int size = GetSizeForDifficulty();
        var (er, ec) = ParseCell(exitLabel);

        bool exitOnEdge =
            (ExitSide.Value == 'A' && ec == 0) ||
            (ExitSide.Value == 'C' && ec == size - 1) ||
            (ExitSide.Value == 'B' && er == 1) ||
            (ExitSide.Value == 'D' && er == size);

        return exitOnEdge;
    }

    private static string GetEdgeMostCellInDirection(List<string> labels, int dx, int dy)
    {
        var coords = labels.Select(lbl => (lbl, rc: ParseCell(lbl))).ToList();

        if (dx == -1) return coords.OrderBy(x => x.rc.col).First().lbl;
        if (dx == +1) return coords.OrderByDescending(x => x.rc.col).First().lbl;
        if (dy == -1) return coords.OrderBy(x => x.rc.row).First().lbl;
        return coords.OrderByDescending(x => x.rc.row).First().lbl;
    }

    private int GetSizeForDifficulty() => Difficulty switch
    {
        "Easy" => 4,
        "Medium" => 5,
        "Hard" => 6,
        _ => 4
    };

    private void RotateSelected(bool isClockwise)
    {
        if (!HasSelection || GameWon) return;

        var (prefix, validCells, _, _) = GetGridRenderInfo();
        var v = Vehicles[SelectedVehicleIndex!.Value];

        var oldLabels = v.Cells.Select(k => StripPrefix(k, prefix)).ToList();

        if (GetOrientation(oldLabels) == Orientation.Unknown)
        {
            UpdateStatus("Rotate blocked: not a straight vehicle.");
            return;
        }

        string pivotLabel = oldLabels[0];
        var (pr, pc) = ParseCell(pivotLabel);

        var newLabels = new List<string>(oldLabels.Count);

        foreach (var lbl in oldLabels)
        {
            var (r, c) = ParseCell(lbl);
            int dr = r - pr;
            int dc = c - pc;

            int ndr, ndc;

            if (isClockwise)
            {
                ndr = dc;
                ndc = -dr;
            }
            else
            {
                ndr = -dc;
                ndc = dr;
            }

            int nr = pr + ndr;
            int nc = pc + ndc;

            newLabels.Add(ToCell(nr, nc));
        }

        foreach (var lbl in newLabels)
        {
            if (!validCells.Contains(lbl))
            {
                UpdateStatus("Rotate blocked: out of bounds.");
                return;
            }
        }

        var newKeys = newLabels.Select(l => prefix + l).ToList();

        if (!IsMoveCollisionFree(SelectedVehicleIndex.Value, newKeys))
        {
            UpdateStatus("Rotate blocked: destination occupied.");
            return;
        }

        if (!IsRotationSweepClear(SelectedVehicleIndex.Value, prefix, oldLabels, newLabels))
        {
            UpdateStatus("Rotate blocked: swing path occupied.");
            return;
        }

        v.Cells = newKeys;
        UpdateStatus(isClockwise ? "Rotated CW." : "Rotated CCW.");
    }

    private bool IsRotationSweepClear(int movingIndex, string prefix, List<string> oldLabels, List<string> newLabels)
    {
        var occupied = new HashSet<string>();
        for (int i = 0; i < Vehicles.Count; i++)
        {
            if (i == movingIndex) continue;
            foreach (var k in Vehicles[i].Cells)
                occupied.Add(k);
        }

        var pivot = oldLabels[0];

        for (int i = 1; i < oldLabels.Count; i++)
        {
            var (or, oc) = ParseCell(oldLabels[i]);
            var (nr, nc) = ParseCell(newLabels[i]);

            int rMin = Math.Min(or, nr);
            int rMax = Math.Max(or, nr);
            int cMin = Math.Min(oc, nc);
            int cMax = Math.Max(oc, nc);

            for (int r = rMin; r <= rMax; r++)
            {
                for (int c = cMin; c <= cMax; c++)
                {
                    var lbl = ToCell(r, c);
                    if (lbl == pivot) continue;

                    var key = prefix + lbl;
                    if (occupied.Contains(key))
                        return false;
                }
            }
        }

        return true;
    }

    private bool IsMoveCollisionFree(int movingIndex, List<string> newKeys)
    {
        var occupied = new HashSet<string>();
        for (int i = 0; i < Vehicles.Count; i++)
        {
            if (i == movingIndex) continue;
            foreach (var k in Vehicles[i].Cells)
                occupied.Add(k);
        }
        return !newKeys.Any(occupied.Contains);
    }

    private static string StripPrefix(string key, string prefix)
    {
        if (key.StartsWith(prefix, StringComparison.Ordinal))
            return key.Substring(prefix.Length);
        return key;
    }

    private enum Orientation { Unknown, Horizontal, Vertical }

    private static Orientation GetOrientation(List<string> labels)
    {
        var coords = labels.Select(ParseCell).ToList();
        bool sameRow = coords.All(x => x.row == coords[0].row);
        bool sameCol = coords.All(x => x.col == coords[0].col);

        if (sameRow && !sameCol) return Orientation.Horizontal;
        if (sameCol && !sameRow) return Orientation.Vertical;
        return Orientation.Unknown;
    }

    private static char ParseType(string s)
    {
        if (string.IsNullOrWhiteSpace(s)) throw new Exception("Empty vehicle type.");
        char t = char.ToUpperInvariant(s.Trim()[0]);
        if (t is not ('C' or 'B' or 'T' or 'P')) throw new Exception($"Unknown vehicle type '{s}'. Use C,B,T,P.");
        return t;
    }

    private static char ParseColor(string s)
    {
        if (string.IsNullOrWhiteSpace(s)) throw new Exception("Empty color.");
        char c = char.ToUpperInvariant(s.Trim()[0]);
        if (c is not ('R' or 'G' or 'B' or 'Y')) throw new Exception($"Unknown color '{s}'. Use R,G,B,Y.");
        return c;
    }

    private static int ExpectedLength(char type) => type switch
    {
        'C' => 2,
        'B' => 3,
        'T' => 4,
        'P' => 2,
        _ => 0
    };

    private static List<string>? BuildOccupiedCellsFromStartEnd(string start, string end)
    {
        var (sr, sc) = ParseCell(start);
        var (er, ec) = ParseCell(end);

        if (sr == er && sc != ec)
        {
            int step = sc < ec ? 1 : -1;
            var list = new List<string>();
            for (int c = sc; c != ec + step; c += step)
                list.Add(ToCell(sr, c));
            return list;
        }

        if (sc == ec && sr != er)
        {
            int step = sr < er ? 1 : -1;
            var list = new List<string>();
            for (int r = sr; r != er + step; r += step)
                list.Add(ToCell(r, sc));
            return list;
        }

        if (sr == er && sc == ec)
            return new List<string> { start };

        return null;
    }

    private static (int row, int col) ParseCell(string cell)
    {
        cell = cell.Trim().ToUpper();
        if (cell.Length < 2) throw new Exception($"Bad cell '{cell}'.");

        string rowPart = cell[..^1];
        char colChar = cell[^1];

        if (!int.TryParse(rowPart, out int row)) throw new Exception($"Bad row in cell '{cell}'.");
        if (colChar < 'A' || colChar > 'Z') throw new Exception($"Bad column in cell '{cell}'.");

        int col = colChar - 'A';
        return (row, col);
    }

    private static string ToCell(int row, int colIndex)
    {
        char col = (char)('A' + colIndex);
        return $"{row}{col}";
    }

    private (string Prefix, List<string> Cells, int CellSizePx, int Cols) GetGridRenderInfo()
    {
        return Difficulty switch
        {
            "Easy" => ("E-", EasyCells, 75, 4),
            "Medium" => ("M-", MediumCells, 60, 5),
            "Hard" => ("H-", HardCells, 50, 6),
            _ => ("E-", EasyCells, 75, 4)
        };
    }

    private (int rowIndex, int colIndex) GetExitRowCol(string prefix)
    {
        if (ExitCellKey == null) return (-1, -1);
        if (!ExitCellKey.StartsWith(prefix, StringComparison.Ordinal)) return (-1, -1);

        string label = ExitCellKey.Substring(prefix.Length);
        var (row, col) = ParseCell(label);
        return (row - 1, col);
    }

    private RenderFragment RenderGrid() => builder =>
    {
        var (prefix, cells, _, _) = GetGridRenderInfo();
        int seq = 0;

        var cellToVehicleIndex = new Dictionary<string, int>();
        for (int i = 0; i < Vehicles.Count; i++)
            foreach (var key in Vehicles[i].Cells)
                cellToVehicleIndex[key] = i;

        foreach (var cell in cells)
        {
            var key = prefix + cell;

            bool hasVehicle = cellToVehicleIndex.TryGetValue(key, out var vIndex);
            Vehicle? vehicle = hasVehicle ? Vehicles[vIndex] : null;

            bool isExit = (ExitCellKey == key);
            bool isSelected = HasSelection && hasVehicle && vIndex == SelectedVehicleIndex!.Value;

            string classes = "cell";
            if (vehicle != null) classes += " occupied " + vehicle.CssClass;
            if (isExit && ExitSide.HasValue) classes += " exit exit-" + ExitSide.Value;
            if (isSelected) classes += " selected";

            builder.OpenElement(seq++, "div");
            builder.AddAttribute(seq++, "class", classes);
            builder.AddAttribute(seq++, "id", key);
            builder.AddAttribute(seq++, "role", "button");
            builder.AddAttribute(seq++, "tabindex", "0");
            builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => SelectVehicleAtCell(key)));
            builder.AddContent(seq++, cell);

            if (vehicle != null && vehicle.Cells.Count > 0 && vehicle.Cells[0] == key)
            {
                builder.OpenElement(seq++, "div");
                builder.AddAttribute(seq++, "class", "veh-label");
                builder.AddContent(seq++, vehicle.Type.ToString());
                builder.CloseElement();
            }

            builder.CloseElement();
        }
    };

    private static string CssClassForColor(char color) => color switch
    {
        'R' => "veh-red",
        'G' => "veh-green",
        'B' => "veh-blue",
        'Y' => "veh-yellow",
        _ => "veh-red"
    };

    private static List<string> BuildCells(int rows, int cols)
    {
        var list = new List<string>(rows * cols);
        for (int r = 1; r <= rows; r++)
            for (int c = 0; c < cols; c++)
                list.Add($"{r}{(char)('A' + c)}");
        return list;
    }

    private async Task UpdateStatus(string message)
    {
        await OnStatusChanged.InvokeAsync(message);
    }

    private async Task NotifyGameWonChanged(bool won)
    {
        await OnGameWonChanged.InvokeAsync(won);
    }

    private class Vehicle
    {
        public char Type { get; set; }
        public char Color { get; set; }
        public string CssClass { get; set; } = "";
        public List<string> Cells { get; set; } = new();
    }
}
