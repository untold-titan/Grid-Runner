@page "/counter"
@using GridRunner.Interfaces
@using GridRunner.Components
@inject IJSRuntime JS

<PageTitle>Block Drag Test</PageTitle>

<h1>Blocks (drag them)</h1>
<button @onclick="RunBlockStacks">Run Block Stack</button>

<div class="stage" @ref="stageRef"
     @onpointermove="OnStagePointerMove"
     @onpointerup="OnStagePointerUp"
     @onpointercancel="OnStagePointerUp">

    @if (hoverActive)
    {
        <div class="ghost"
             style="left:@($"{hoverX}px"); top:@($"{hoverY}px");">
            <svg width="90" height="90" viewBox="0 0 92 92">
                <path d="
                                M 1 1
                                L 15 1
                                L 15 15
                                L 30 1
                                L 91 1
                                L 91 75
                                L 30 75
                                L 15 91
                                L 15 75
                                L 1 75
                                Z"
                      fill="transparent"
                      stroke="#000000"
                      stroke-width="3" />
            </svg>
        </div>
    }

    @foreach (var b in blocks)
    {
        <CodeBlock block="b" onPointerDown="OnBlockPointerDown" />
    }
</div>

<style>
    .stage {
        position: relative;
        height: 70vh;
        border: 1px solid #ccc;
        user-select: none;
        touch-action: none;
        overflow: hidden;
    }

    .ghost {
        position: absolute;
        pointer-events: none;
        opacity: 0.9;
        z-index: 0;
    }
</style>

<script>
    window.blockDrag = {
        rect: (el) => {
            const r = el.getBoundingClientRect();
            return { left: r.left, top: r.top };
        }
    };
</script>

@code {
    private List<Block> blocks = new() {
        new StartBlock() { Id = 0, X = 40, Y = 40, Locked = true, ParentId = null, Description = "Start" },
        new ConsoleBlock() { Id = 1, X = 180, Y = 40, Locked = false, ParentId = null, Description = "Console Write"},
        new ConsoleBlock() { Id = 2, X = 280, Y = 40, Locked = false,  ParentId = null }
    };


    # region Drag and Snap Logic
    private ElementReference stageRef;

    private double fixedX = 40;
    private double fixedY = 40;

    private int? activeId = null;
    private bool dragging = false;
    private bool activeWasLockedAtDown = false;
    private double grabOffsetX = 0;
    private double grabOffsetY = 0;
    private double stageLeft = 0;
    private double stageTop = 0;

    private bool hoverActive = false;
    private double hoverX = 0;
    private double hoverY = 0;

    private const double StackStepY = 71;

    private async void OnBlockPointerDown(PointerEventArgs e, int id)
    {
        activeId = id;
        dragging = true;

        var bottomLockedId = BottomLockedIdExcluding(null);
        var selected = blocks.First(x => x.Id == id);

        if (selected.Locked && selected.Id != bottomLockedId)
        {
            activeId = null;
            dragging = false;
            return;
        }

        activeWasLockedAtDown = selected.Locked;

        if (selected.Locked)
        {
            var idx = blocks.FindIndex(x => x.Id == id);
            selected = selected with { Locked = false };
            blocks[idx] = selected;
        }

        var stageRect = await JS.InvokeAsync<Rect>("blockDrag.rect", stageRef);
        stageLeft = stageRect.Left;
        stageTop = stageRect.Top;

        var b = blocks.First(x => x.Id == id);

        grabOffsetX = e.ClientX - (stageLeft + b.X);
        grabOffsetY = e.ClientY - (stageTop + b.Y);

        UpdateHoverPreview(b);
    }

    private void OnStagePointerMove(PointerEventArgs e)
    {
        if (!dragging || activeId is null) return;

        var idx = blocks.FindIndex(x => x.Id == activeId.Value);
        if (idx < 0) return;

        var b = blocks[idx];

        b.X = Math.Round(e.ClientX - stageLeft - grabOffsetX);
        b.Y = Math.Round(e.ClientY - stageTop - grabOffsetY);

        blocks[idx] = b;

        UpdateHoverPreview(b);
    }

    private void OnStagePointerUp(PointerEventArgs e)
    {

        if (!dragging || activeId is null) return;

        var idx = blocks.FindIndex(x => x.Id == activeId.Value);
        if (idx >= 0)
        {
            var b = blocks[idx];

            if (hoverActive)
            {

                b = b with
                {
                    X = hoverX,
                    Y = hoverY,
                    Locked = true,
                    ParentId = hoverAnchorId
                };
            }
            else
            {

                if (activeWasLockedAtDown)
                    b = b with { Locked = false, ParentId = null };
            }

            blocks[idx] = b;
        }

        dragging = false;
        activeId = null;
        hoverActive = false;
        activeWasLockedAtDown = false;
        hoverAnchorId = null;
    }

    private int? hoverAnchorId = null;

    private void UpdateHoverPreview(Block dragged)
    {

        hoverAnchorId = BottomLockedIdExcluding(activeId);

        double anchorX, anchorY;

        if (hoverAnchorId is null)
        {
            anchorX = fixedX;
            anchorY = fixedY;
        }
        else
        {
            var anchor = blocks.First(b => b.Id == hoverAnchorId.Value);
            anchorX = anchor.X;
            anchorY = anchor.Y;
        }

        var targetX = anchorX;
        var targetY = anchorY + StackStepY;

        double zoneLeft = anchorX - 45;
        double zoneRight = anchorX + 45;
        double zoneTop = anchorY + 60;
        double zoneBottom = anchorY + 120;

        bool inside =
            dragged.X >= zoneLeft &&
            dragged.X <= zoneRight &&
            dragged.Y >= zoneTop &&
            dragged.Y <= zoneBottom;

        hoverActive = inside;

        if (hoverActive)
        {
            hoverX = targetX;
            hoverY = targetY;
        }
    }

    private int? BottomLockedIdExcluding(int? excludeId)
    {
        var locked = blocks
            .Where(b => b.Locked && b.Id != excludeId)
            .OrderByDescending(b => b.Y)
            .FirstOrDefault();

        return blocks.Any(b => b.Locked && b.Id != excludeId) ? locked?.Id : (int?)null;
    }

    private record Rect(double Left, double Top);

    #endregion

    # region Execution Logic

    private List<List<Block>> blockStacks = new();

    private void RunBlockStacks()
    {
        BuildBlockStacks();
        // Execute stacks!
        Console.WriteLine("Executing Stacks:");
        for (int i = 0; i < blockStacks.OrderBy(list => list.Count).ToList()[0].Count(); i++)
        {
            foreach (var stack in blockStacks)
            {
                var block = stack.ElementAtOrDefault(i);
                if (block != null)
                {
                    block.RunBlock("abcd");
                }
            }
        }
    }

    private void BuildBlockStacks()
    {
        // Get the start blocks
        blockStacks.Clear();
        foreach (var startBlock in blocks.Where(b => b.GetType() == typeof(StartBlock)))
        {
            blockStacks.Add(new List<Block>() { startBlock });
        }

        List<int> notOrphaned = new();

        Console.WriteLine("Target: " + (blocks.Count() - blocks.Where(b => b.GetType() == typeof(StartBlock)).Count()));
        while (notOrphaned.Count() < blocks.Count() - blocks.Where(b => b.GetType() == typeof(StartBlock)).Count())
        {
            Console.WriteLine("N/A Orphaned = " + notOrphaned.Count);
            foreach (var block in blocks.Where(b => b.GetType() != typeof(StartBlock)))
            {
                foreach (var stack in blockStacks)
                {
                    if (stack.FirstOrDefault(b => b.Id == block.ParentId) != null && !stack.Contains(block))
                    {
                        stack.Add(block);
                        notOrphaned.Add(block.Id);
                    }
                }
            }
        }
    }

    # endregion
}