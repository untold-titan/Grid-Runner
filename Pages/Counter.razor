@page "/counter"
@using GridRunner.Interfaces
@inject IJSRuntime JS

<PageTitle>Block Drag Test</PageTitle>

<h1>Blocks (drag them)</h1>
<button @onclick="RunBlockStacks">Execute Blocks</button>

<div class="layout">

    <div class="panel">

        <div class="panel-block"
             @onpointerdown="(e) => OnPalettePointerDown(e, 6, typeof(ConsoleBlock))">
            <svg width="90" height="90" viewBox="0 0 92 92">
                <path d="
                    M 1 1
                    L 15 1
                    L 15 15
                    L 30 1
                    L 91 1
                    L 91 75
                    L 30 75
                    L 15 91
                    L 15 75
                    L 1 75
                    Z"
                      fill="@PaletteGray"
                      stroke="#000000"
                      stroke-width="1" />
            </svg>
        </div>

        <details class="drop" open>
            <summary class="drop-title">Move</summary>

            <div class="drop-body">
                @for (int i = 0; i < 4; i++)
                {
                    <div class="panel-block"
                         @onpointerdown="(e) => OnPalettePointerDown(e, i, typeof(ConsoleBlock))">
                        <svg width="90" height="90" viewBox="0 0 92 92">
                            <path d="
                                                    M 1 1
                                                    L 15 1
                                                    L 15 15
                                                    L 30 1
                                                    L 91 1
                                                    L 91 75
                                                    L 30 75
                                                    L 15 91
                                                    L 15 75
                                                    L 1 75
                                                    Z"
                                  fill="@PaletteGray"
                                  stroke="#000000"
                                  stroke-width="1" />
                        </svg>
                    </div>
                }
            </div>
        </details>

        <details class="drop" open>
            <summary class="drop-title">Rotate</summary>

            <div class="drop-body">
                @for (int i = 0; i < 2; i++)
                {
                    <div class="panel-block"
                         @onpointerdown="(e) => OnPalettePointerDown(e, i + 4, typeof(ConsoleBlock))">
                        <svg width="90" height="90" viewBox="0 0 92 92">
                            <path d="
                                                    M 1 1
                                                    L 15 1
                                                    L 15 15
                                                    L 30 1
                                                    L 91 1
                                                    L 91 75
                                                    L 30 75
                                                    L 15 91
                                                    L 15 75
                                                    L 1 75
                                                    Z"
                                  fill="@PaletteGray"
                                  stroke="#000000"
                                  stroke-width="1" />
                        </svg>
                    </div>
                }
            </div>
        </details>
    </div>

    <div class="stage" @ref="stageRef"
         @onpointermove="OnStagePointerMove"
         @onpointerup="OnStagePointerUp"
         @onpointercancel="OnStagePointerUp">

        @* <div class="fixed"
             style="left:@($"{fixedX}px"); top:@($"{fixedY}px");">
            <svg width="90" height="90" viewBox="0 0 92 92">
                <path d="
                    M 1 1
                    L 15 1
                    L 15 15
                    L 30 1
                    L 91 1
                    L 91 75
                    L 30 75
                    L 15 91
                    L 15 75
                    L 1 75
                    Z"
                      fill="@fixedColor"
                      stroke="#000000"
                      stroke-width="1" />
            </svg>
        </div> *@


        @if (hoverActive)
        {
            <div class="ghost"
                 style="left:@($"{hoverX}px"); top:@($"{hoverY}px");">
                <svg width="90" height="90" viewBox="0 0 92 92">
                    <path d="
                                            M 1 1
                                            L 15 1
                                            L 15 15
                                            L 30 1
                                            L 91 1
                                            L 91 75
                                            L 30 75
                                            L 15 91
                                            L 15 75
                                            L 1 75
                                            Z"
                          fill="transparent"
                          stroke="#000000"
                          stroke-width="3" />
                </svg>
            </div>
        }

        @foreach (var b in blocks)
        {
            <GridRunner.Components.CodeBlock block="b" onPointerDown="OnBlockPointerDown" />
        }
    </div>
</div>

<style>
    .stage {
        position: relative;
        height: 70vh;
        border: 1px solid #ccc;
        user-select: none;
        touch-action: none;
        overflow: visible;
    }

    .layout {
        display: flex;
        gap: 12px;
        height: 70vh;
    }

    .panel {
        width: 130px;
        border: 1px solid #ccc;
        background: #f7f7f7;
        padding: 4px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        user-select: none;
        touch-action: none;
        height: 70vh;
        overflow-y: auto;
    }

    .panel-block {
        display: flex;
        align-items: center;
        justify-content: flex-start;
        padding: 6px;
        border-radius: 8px;
        cursor: grab;
        user-select: none;
    }

        .panel-block:active {
            cursor: grabbing;
        }

        .panel-block:active {
            cursor: grabbing;
        }

    .draggable {
        position: absolute;
        cursor: grab;
        touch-action: none;
        z-index: 2;
    }

        .draggable:active {
            cursor: grabbing;
        }

        .draggable.locked {
            cursor: not-allowed;
            opacity: 0.95;
        }

    .fixed {
        position: absolute;
        pointer-events: none;
        z-index: 1;
    }

    .ghost {
        position: absolute;
        pointer-events: none;
        opacity: 0.9;
        z-index: 0;
    }
</style>

<script>
    window.blockDrag = {
        rect: (el) => {
            const r = el.getBoundingClientRect();
            return { left: r.left, top: r.top };
        }
    };
</script>

@code {
    private ElementReference stageRef;

    private List<Block> blocks = new()
    {
        new StartBlock() { Id = 0, X = 40, Y = 40, Locked = true, ParentId = null, FillColor = "#00ff00" },
        new StartBlock() { Id = 1, X = 200, Y = 40, Locked = true, ParentId = null, FillColor = "#00ff00" }
    };

    private string fixedColor = "#FFA500";
    private const string PaletteGray = "#DDDDDD";
    private int nextBlockId = 1;
    private int? activeId = null;
    private bool dragging = false;
    private bool activeWasLockedAtDown = false;
    private double grabOffsetX = 0;
    private double grabOffsetY = 0;
    private double stageLeft = 0;
    private double stageTop = 0;

    private bool hoverActive = false;
    private double hoverX = 0;
    private double hoverY = 0;

    private int? hoverAnchorId = null;

    private const double StackStepY = 71;


    /// <summary>
    /// Handles the selection of blocks
    /// </summary>
    /// <param name="e">Pointer event</param>
    /// <param name="id">The ID of the block being moved</param>
    private async void OnBlockPointerDown(PointerEventArgs e, int id)
    {
        activeId = id;
        dragging = true;

        var bottomLockedId = BottomLockedIdExcluding(null);
        var selected = blocks.First(x => x.Id == id);

        if (selected.Locked && selected.Id != bottomLockedId)
        {
            activeId = null;
            dragging = false;
            return;
        }

        activeWasLockedAtDown = selected.Locked;

        if (selected.Locked)
        {
            var idx = blocks.FindIndex(x => x.Id == id);
            selected = selected with { Locked = false, FillColor = PaletteGray };
            blocks[idx] = selected;
        }

        var stageRect = await JS.InvokeAsync<Rect>("blockDrag.rect", stageRef);
        stageLeft = stageRect.Left;
        stageTop = stageRect.Top;

        var b = blocks.First(x => x.Id == id);

        grabOffsetX = e.ClientX - (stageLeft + b.X);
        grabOffsetY = e.ClientY - (stageTop + b.Y);

        UpdateHoverPreview(b);
    }

    /// <summary>
    /// Handles the movement of blocks
    /// </summary>
    /// <param name="e">Pointer event</param>
    private void OnStagePointerMove(PointerEventArgs e)
    {
        if (!dragging || activeId is null) return;

        var idx = blocks.FindIndex(x => x.Id == activeId.Value);
        if (idx < 0) return;

        var b = blocks[idx];

        b.X = Math.Round(e.ClientX - stageLeft - grabOffsetX);
        b.Y = Math.Round(e.ClientY - stageTop - grabOffsetY);

        blocks[idx] = b;

        UpdateHoverPreview(b);
    }

    /// <summary>
    /// Handles release and snapping of blocks
    /// </summary>
    /// <param name="e">Pointer Event</param>
    private void OnStagePointerUp(PointerEventArgs e)
    {
        if (!dragging || activeId is null) return;

        var idx = blocks.FindIndex(x => x.Id == activeId.Value);

        if (idx >= 0)
        {
            var b = blocks[idx];

            if (hoverActive)
            {
                b = b with
                {
                    X = hoverX,
                    Y = hoverY,
                    Locked = true,
                    ParentId = hoverAnchorId,
                    FillColor = fixedColor
                };

                blocks[idx] = b;
            }
            else
            {
                blocks.RemoveAt(idx);
            }
        }

        dragging = false;
        activeId = null;
        hoverActive = false;
        activeWasLockedAtDown = false;
        hoverAnchorId = null;
    }

    /// <summary>
    /// Checks all stacks for valid targets to attach blocks to and if theres a valid one, it will display the ghost there
    /// </summary>
    /// <param name="dragged">The block that is being dragged</param>
    private void UpdateHoverPreview(Block dragged)
    {
        hoverActive = false;
        hoverAnchorId = null;

        // Find all possible stack anchors (locked blocks, or use StartBlock if you prefer)
        var anchors = blocks.Where(b => b.Locked && b.Id != activeId).ToList();

        foreach (var anchor in anchors)
        {
            double anchorX = anchor.X;
            double anchorY = anchor.Y;

            var targetX = anchorX;
            var targetY = anchorY + StackStepY;

            double zoneLeft = anchorX - 45;
            double zoneRight = anchorX + 45;
            double zoneTop = anchorY + 60;
            double zoneBottom = anchorY + 120;

            bool inside =
                dragged.X >= zoneLeft &&
                dragged.X <= zoneRight &&
                dragged.Y >= zoneTop &&
                dragged.Y <= zoneBottom;

            if (inside)
            {
                hoverActive = true;
                hoverAnchorId = anchor.Id;
                hoverX = targetX;
                hoverY = targetY;
                break; // Stop at the first valid stack
            }
        }
    }

    /// <summary>
    /// Returns the block closest to the target
    /// </summary>
    /// <param name="excludeId"></param>
    /// <returns></returns>
    private int? BottomLockedIdExcluding(int? excludeId)
    {
        var locked = blocks
            .Where(b => b.Locked && b.Id != excludeId)
            .OrderByDescending(b => b.Y)
            .FirstOrDefault();

        return blocks.Any(b => b.Locked && b.Id != excludeId) ? locked.Id : (int?)null;
    }

    private async Task OnPalettePointerDown(PointerEventArgs e, int paletteIndex, Type blockToInstantiate)
    {
        nextBlockId = blocks.Count + 1;
        dragging = true;
        activeWasLockedAtDown = false;

        var stageRect = await JS.InvokeAsync<Rect>("blockDrag.rect", stageRef);
        stageLeft = stageRect.Left;
        stageTop = stageRect.Top;

        var spawnX = Math.Round((e.ClientX - stageLeft) - 45);
        var spawnY = Math.Round((e.ClientY - stageTop) - 45);

        Block newBlock;
        if (blockToInstantiate == typeof(ConsoleBlock))
        {
            newBlock = new ConsoleBlock() { Id = nextBlockId, X = spawnX, Y = spawnY, Locked = false, ParentId = null, FillColor = PaletteGray };
        }
        else
        {
            newBlock = new ConsoleBlock();
        }

        blocks.Add(newBlock);

        activeId = newBlock.Id;

        grabOffsetX = 45;
        grabOffsetY = 45;

        UpdateHoverPreview(newBlock);
    }

    private record Rect(double Left, double Top);

    #region Execution Logic

    private List<List<Block>> blockStacks = new();

    private void RunBlockStacks()
    {
        BuildBlockStacks();
        // Execute stacks!
        Console.WriteLine("Executing Stacks:");
        for (int i = 0; i < blockStacks.OrderBy(list => list.Count).ToList()[0].Count(); i++)
        {
            foreach (var stack in blockStacks)
            {
                var block = stack.ElementAtOrDefault(i);
                if (block != null)
                {
                    block.RunBlock("abcd");
                }
            }
        }
    }

    private void BuildBlockStacks()
    {
        //Get the start blocks
        blockStacks.Clear();
        foreach (var startBlock in blocks.Where(b => b.GetType() == typeof(StartBlock)))
        {
            blockStacks.Add(new List<Block>() { startBlock });
        }

        List<int> notOrphaned = new();

        Console.WriteLine("Target: " + (blocks.Count() - blocks.Where(b => b.GetType() == typeof(StartBlock)).Count()));
        while (notOrphaned.Count() < blocks.Count() - blocks.Where(b => b.GetType() == typeof(StartBlock)).Count())
        {
            Console.WriteLine("N/A Orphaned = " + notOrphaned.Count);
            foreach (var block in blocks.Where(b => b.GetType() != typeof(StartBlock)))
            {
                foreach (var stack in blockStacks)
                {
                    if (stack.FirstOrDefault(b => b.Id == block.ParentId) != null && !stack.Contains(block))
                    {
                        stack.Add(block);
                        notOrphaned.Add(block.Id);
                    }
                }
            }
        }
    }

    # endregion
}