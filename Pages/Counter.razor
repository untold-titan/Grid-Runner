@page "/counter"
@using GridRunner.Interfaces
@using GridRunner.Components
@inject IJSRuntime JS

<PageTitle>Block Drag Test</PageTitle>

<h1>Blocks (drag them)</h1>
<button @onclick="RunBlockStacks">Run Block Stack</button>

<div class="layout">

    <div class="panel">

        <div class="panel-block"
            @onpointerdown="(e) => OnPalettePointerDown(e, 6)">
            <svg width="90" height="90" viewBox="0 0 92 92">
                <path d="
                    M 1 1
                    L 15 1
                    L 15 15
                    L 30 1
                    L 91 1
                    L 91 75
                    L 30 75
                    L 15 91
                    L 15 75
                    L 1 75
                    Z"
                    fill="@PaletteGray"
                    stroke="#000000"
                    stroke-width="1" />
            </svg>
        </div>

        <details class="drop" open>
            <summary class="drop-title">Move</summary>

            <div class="drop-body">
                @for (int i = 0; i < 4; i++) {
                    <div class="panel-block"
                         @onpointerdown="(e) => OnPalettePointerDown(e, i)">
                        <svg width="90" height="90" viewBox="0 0 92 92">
                            <path d="
                                M 1 1
                                L 15 1
                                L 15 15
                                L 30 1
                                L 91 1
                                L 91 75
                                L 30 75
                                L 15 91
                                L 15 75
                                L 1 75
                                Z"
                                fill="@PaletteGray"
                                stroke="#000000"
                               stroke-width="1" />
                        </svg>
                    </div>
                }
            </div>
        </details>

        <details class="drop" open>
            <summary class="drop-title">Rotate</summary>

            <div class="drop-body">
                @for (int i = 0; i < 2; i++) {
                    <div class="panel-block"
                         @onpointerdown="(e) => OnPalettePointerDown(e, i + 4)">
                        <svg width="90" height="90" viewBox="0 0 92 92">
                            <path d="
                                M 1 1
                                L 15 1
                                L 15 15
                                L 30 1
                                L 91 1
                                L 91 75
                                L 30 75
                                L 15 91
                                L 15 75
                                L 1 75
                                Z"
                                fill="@PaletteGray"
                                stroke="#000000"
                                stroke-width="1" />
                        </svg>
                    </div>
                }
            </div>
        </details>
    </div>

    <div class="stage" @ref="stageRef"
         @onpointermove="OnStagePointerMove"
         @onpointerup="OnStagePointerUp"
         @onpointercancel="OnStagePointerUp">

        <div class="fixed"
             style="left:@($"{fixedX}px"); top:@($"{fixedY}px");">
            <svg width="90" height="90" viewBox="0 0 92 92">
                <path d="
                    M 1 1
                    L 15 1
                    L 15 15
                    L 30 1
                    L 91 1
                    L 91 75
                    L 30 75
                    L 15 91
                    L 15 75
                    L 1 75
                    Z"
                    fill="@fixedColor"
                    stroke="#000000"
                    stroke-width="1" />
            </svg>
        </div>

        @if (hoverActive) {
            <div class="ghost"
                 style="left:@($"{hoverX}px"); top:@($"{hoverY}px");">
                <svg width="90" height="90" viewBox="0 0 92 92">
                    <path d="
                        M 1 1
                        L 15 1
                        L 15 15
                        L 30 1
                        L 91 1
                        L 91 75
                        L 30 75
                        L 15 91
                        L 15 75
                        L 1 75
                        Z"
                        fill="transparent"
                        stroke="#000000"
                        stroke-width="3" />
                </svg>
            </div>
        }

        @foreach (var b in blocks) {
            <div class="draggable @(b.Locked ? "locked" : "")"
                 style="left:@($"{b.X}px"); top:@($"{b.Y}px");"
                 @onpointerdown="(e) => OnBlockPointerDown(e, b.Id)">
                <svg width="90" height="90" viewBox="0 0 92 92">
                    <path d="
                        M 1 1
                        L 15 1
                        L 15 15
                        L 30 1
                        L 91 1
                        L 91 75
                        L 30 75
                        L 15 91
                        L 15 75
                        L 1 75
                        Z"
                        fill="@b.FillColor"
                        stroke="#000000"
                        stroke-width="1" />
                </svg>
            </div>
        }
    </div>
</div>

<style>
    .stage {
        position: relative;
        height: 70vh;
        border: 1px solid #ccc;
        user-select: none;
        touch-action: none;
        overflow: visible;
    }

    .layout {
        display: flex;
        gap: 12px;
        height: 70vh;
    }

    .panel {
        width: 130px;
        border: 1px solid #ccc;
        background: #f7f7f7;
        padding: 4px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        user-select: none;
        touch-action: none;
        height: 70vh;
        overflow-y: auto;
    }

    .panel-block {
        display: flex;
        align-items: center;
        justify-content: flex-start;
        padding: 6px;
        border-radius: 8px;
        cursor: grab;
        user-select: none;
    }

    .panel-block:active { cursor: grabbing; }

    .panel-block:active {
        cursor: grabbing;
    }

    .ghost {
        position: absolute;
        pointer-events: none;
        opacity: 0.9;
        z-index: 0;
    }
</style>

<script>
    window.blockDrag = {
        rect: (el) => {
            const r = el.getBoundingClientRect();
            return { left: r.left, top: r.top };
        }
    };
</script>

@code {
    private List<Block> blocks = new() {
        new StartBlock() { Id = 0, X = 40, Y = 40, Locked = true, ParentId = null, Description = "Start" },
        new ConsoleBlock() { Id = 1, X = 180, Y = 40, Locked = false, ParentId = null, Description = "Console Write"},
        new ConsoleBlock() { Id = 2, X = 280, Y = 40, Locked = false,  ParentId = null }
    };


    # region Drag and Snap Logic
    private ElementReference stageRef;

    private double fixedX = 40;
    private double fixedY = 40;

    private string fixedColor = "#FFA500";
    private const string PaletteGray = "#DDDDDD";
    private int nextBlockId = 1;
    private int? activeId = null;
    private bool dragging = false;
    private bool activeWasLockedAtDown = false;
    private double grabOffsetX = 0;
    private double grabOffsetY = 0;
    private double stageLeft = 0;
    private double stageTop = 0;

    private bool hoverActive = false;
    private double hoverX = 0;
    private double hoverY = 0;

    private const double StackStepY = 71;

    private async void OnBlockPointerDown(PointerEventArgs e, int id)
    {
        activeId = id;
        dragging = true;

        var bottomLockedId = BottomLockedIdExcluding(null);
        var selected = blocks.First(x => x.Id == id);

        if (selected.Locked && selected.Id != bottomLockedId)
        {
            activeId = null;
            dragging = false;
            return;
        }

        activeWasLockedAtDown = selected.Locked;

        if (selected.Locked) {
           var idx = blocks.FindIndex(x => x.Id == id);
            selected = selected with { Locked = false, FillColor = PaletteGray };
            blocks[idx] = selected;
        }

        var stageRect = await JS.InvokeAsync<Rect>("blockDrag.rect", stageRef);
        stageLeft = stageRect.Left;
        stageTop = stageRect.Top;

        var b = blocks.First(x => x.Id == id);

        grabOffsetX = e.ClientX - (stageLeft + b.X);
        grabOffsetY = e.ClientY - (stageTop + b.Y);

        UpdateHoverPreview(b);
    }

    private void OnStagePointerMove(PointerEventArgs e)
    {
        if (!dragging || activeId is null) return;

        var idx = blocks.FindIndex(x => x.Id == activeId.Value);
        if (idx < 0) return;

        var b = blocks[idx];

        b.X = Math.Round(e.ClientX - stageLeft - grabOffsetX);
        b.Y = Math.Round(e.ClientY - stageTop - grabOffsetY);

        blocks[idx] = b;

        UpdateHoverPreview(b);
    }

    private void OnStagePointerUp(PointerEventArgs e) {
        if (!dragging || activeId is null) return;

        var idx = blocks.FindIndex(x => x.Id == activeId.Value);

        if (idx >= 0) {
        var b = blocks[idx];

            if (hoverActive) {
                b = b with {
                    X = hoverX,
                    Y = hoverY,
                    Locked = true,
                    ParentId = hoverAnchorId,
                    FillColor = fixedColor
                };

                blocks[idx] = b;
            }
            else {
                blocks.RemoveAt(idx);
            }
        }

        dragging = false;
        activeId = null;
        hoverActive = false;
        activeWasLockedAtDown = false;
        hoverAnchorId = null;
}

    private int? hoverAnchorId = null;

    private void UpdateHoverPreview(Block dragged)
    {

        hoverAnchorId = BottomLockedIdExcluding(activeId);

        double anchorX, anchorY;

        if (hoverAnchorId is null)
        {
            anchorX = fixedX;
            anchorY = fixedY;
        }
        else
        {
            var anchor = blocks.First(b => b.Id == hoverAnchorId.Value);
            anchorX = anchor.X;
            anchorY = anchor.Y;
        }

        var targetX = anchorX;
        var targetY = anchorY + StackStepY;

        double zoneLeft = anchorX - 45;
        double zoneRight = anchorX + 45;
        double zoneTop = anchorY + 60;
        double zoneBottom = anchorY + 120;

        bool inside =
            dragged.X >= zoneLeft &&
            dragged.X <= zoneRight &&
            dragged.Y >= zoneTop &&
            dragged.Y <= zoneBottom;

        hoverActive = inside;

        if (hoverActive)
        {
            hoverX = targetX;
            hoverY = targetY;
        }
    }

    private int? BottomLockedIdExcluding(int? excludeId)
    {
        var locked = blocks
            .Where(b => b.Locked && b.Id != excludeId)
            .OrderByDescending(b => b.Y)
            .FirstOrDefault();

        return blocks.Any(b => b.Locked && b.Id != excludeId) ? locked?.Id : (int?)null;
    }

    private async Task OnPalettePointerDown(PointerEventArgs e, int paletteIndex) {

        dragging = true;
        activeWasLockedAtDown = false;

        var stageRect = await JS.InvokeAsync<Rect>("blockDrag.rect", stageRef);
        stageLeft = stageRect.Left;
        stageTop = stageRect.Top;

        var spawnX = Math.Round((e.ClientX - stageLeft) - 45);
        var spawnY = Math.Round((e.ClientY - stageTop) - 45);

        var newBlock = new ConsoleBlock() {Id = nextBlockId++, X = spawnX, Y = spawnY, Locked = false, ParentId = null, FillColor = PaletteGray};
        blocks.Add(newBlock);

        activeId = newBlock.Id;

        grabOffsetX = 45;
        grabOffsetY = 45;

        UpdateHoverPreview(newBlock);
    }

    private record Rect(double Left, double Top);

    #endregion

    # region Execution Logic

    private List<List<Block>> blockStacks = new();

    private void RunBlockStacks()
    {
        BuildBlockStacks();
        // Execute stacks!
        Console.WriteLine("Executing Stacks:");
        for (int i = 0; i < blockStacks.OrderBy(list => list.Count).ToList()[0].Count(); i++)
        {
            foreach (var stack in blockStacks)
            {
                var block = stack.ElementAtOrDefault(i);
                if (block != null)
                {
                    block.RunBlock("abcd");
                }
            }
        }
    }

    private void BuildBlockStacks()
    {
        // Get the start blocks
        blockStacks.Clear();
        foreach (var startBlock in blocks.Where(b => b.GetType() == typeof(StartBlock)))
        {
            blockStacks.Add(new List<Block>() { startBlock });
        }

        List<int> notOrphaned = new();

        Console.WriteLine("Target: " + (blocks.Count() - blocks.Where(b => b.GetType() == typeof(StartBlock)).Count()));
        while (notOrphaned.Count() < blocks.Count() - blocks.Where(b => b.GetType() == typeof(StartBlock)).Count())
        {
            Console.WriteLine("N/A Orphaned = " + notOrphaned.Count);
            foreach (var block in blocks.Where(b => b.GetType() != typeof(StartBlock)))
            {
                foreach (var stack in blockStacks)
                {
                    if (stack.FirstOrDefault(b => b.Id == block.ParentId) != null && !stack.Contains(block))
                    {
                        stack.Add(block);
                        notOrphaned.Add(block.Id);
                    }
                }
            }
        }
    }

    # endregion
}