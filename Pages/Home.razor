@page "/"
@using System.Text
@using Microsoft.AspNetCore.Components.Forms

<PageTitle>Home</PageTitle>

<h1>Grid Test (File-driven)</h1>

<div class="controls">
    <label>
        Difficulty:
        <select @bind="SelectedDifficulty">
            <option value="Easy">Easy (4x4)</option>
            <option value="Medium">Medium (5x5)</option>
            <option value="Hard">Hard (6x6)</option>
        </select>
    </label>

    <label class="file">
        Load level file (.txt):
        <InputFile OnChange="OnFileSelected" accept=".txt" />
    </label>

    <button @onclick="LoadSampleLine" disabled="@GameWon">Load Sample Line</button>
    <button @onclick="ClearLevel">Clear</button>

    @if (GameWon)
    {
        <button @onclick="PlayAgain">Play Again</button>
    }
</div>

<div class="controls">
    <button @onclick="MoveSelectedUp" disabled="@(!HasSelection || GameWon)">Up</button>
    <button @onclick="MoveSelectedDown" disabled="@(!HasSelection || GameWon)">Down</button>
    <button @onclick="MoveSelectedLeft" disabled="@(!HasSelection || GameWon)">Left</button>
    <button @onclick="MoveSelectedRight" disabled="@(!HasSelection || GameWon)">Right</button>
    <button @onclick="RotateSelectedCounterClockwise" disabled="@(!HasSelection || GameWon)">Rotate CCW</button>
    <button @onclick="RotateSelectedClockwise" disabled="@(!HasSelection || GameWon)">Rotate CW</button>

    <span class="selected-info">
        @if (HasSelection)
        {
            <span>Selected: @SelectedVehicleDisplay</span>
        }
        else
        {
            <span>Selected: (none) — click a vehicle</span>
        }
    </span>
</div>

@if (!string.IsNullOrWhiteSpace(StatusMessage))
{
    <div class="status @(GameWon ? "win" : "")">@StatusMessage</div>
}

@{
    var (prefix, _, cellSizePx, cols) = GetGridRenderInfo();
    var (exitRow, exitCol) = GetExitRowCol(prefix);
    string exitClass = ExitSide.HasValue ? $"exit-{ExitSide.Value}" : "";

    string gridStyle =
        $"--cell-size:{cellSizePx}px;" +
        $"--cols:{cols};" +
        $"--exit-row:{exitRow};" +
        $"--exit-col:{exitCol};" +
        $"display:grid; grid-template-columns:repeat({cols},{cellSizePx}px);" +
        $"grid-auto-rows:{cellSizePx}px;";
}

<div class="board">
    <div class="grid-container @GridCssClass @exitClass" style="@gridStyle">
        @RenderGrid()
        @RenderVehicleSprites()
    </div>
</div>

@code {
    private string SelectedDifficulty = "Easy";
    private string StatusMessage = "";

    private char? ExitSide;
    private string? ExitCellKey;

    private readonly List<Vehicle> Vehicles = new();

    private int? SelectedVehicleIndex;
    private bool HasSelection => SelectedVehicleIndex.HasValue && SelectedVehicleIndex.Value >= 0 && SelectedVehicleIndex.Value < Vehicles.Count;

    private string SelectedVehicleDisplay => HasSelection
        ? $"{Vehicles[SelectedVehicleIndex!.Value].Type} ({Vehicles[SelectedVehicleIndex!.Value].Color})"
        : "(none)";

    private bool GameWon = false;
    private string? LastLevelLine;

    private readonly List<string> EasyCells = BuildCells(4, 4);
    private readonly List<string> MediumCells = BuildCells(5, 5);
    private readonly List<string> HardCells = BuildCells(6, 6);

    private string GridCssClass => SelectedDifficulty switch
    {
        "Easy" => "easy",
        "Medium" => "medium",
        "Hard" => "hard",
        _ => "easy"
    };

    private async Task OnFileSelected(InputFileChangeEventArgs e)
    {
        try
        {
            var file = e.File;
            using var stream = file.OpenReadStream(maxAllowedSize: 1024 * 1024);
            using var reader = new StreamReader(stream, Encoding.UTF8);
            var content = await reader.ReadToEndAsync();
            LoadLevelFromText(content);
        }
        catch (Exception ex)
        {
            StatusMessage = $"File read error: {ex.Message}";
        }
    }

    private void LoadSampleLine()
    {
        string sample = "A,1A;P,R,3C,4C;C,B,2A,2B;C,G,3A,4A;T,B,1D,3D";
        LoadLevelLine(sample);
    }

    private void PlayAgain()
    {
        if (!string.IsNullOrWhiteSpace(LastLevelLine))
            LoadLevelLine(LastLevelLine!);
        else
            ClearLevel();
    }

    private void ClearLevel()
    {
        Vehicles.Clear();
        ExitSide = null;
        ExitCellKey = null;
        SelectedVehicleIndex = null;
        GameWon = false;
        StatusMessage = "Cleared.";
    }

    private void LoadLevelFromText(string text)
    {
        var lines = text.Replace("\r\n", "\n").Split('\n')
                        .Select(l => l.Trim())
                        .Where(l => !string.IsNullOrWhiteSpace(l))
                        .ToList();

        if (lines.Count == 0)
        {
            StatusMessage = "No level lines found.";
            return;
        }

        LoadLevelLine(lines[0]);
    }

    private void LoadLevelLine(string line)
    {
        try
        {
            Vehicles.Clear();
            ExitSide = null;
            ExitCellKey = null;
            SelectedVehicleIndex = null;
            GameWon = false;
            StatusMessage = "";

            LastLevelLine = line;

            var parts = line.Split(';', StringSplitOptions.RemoveEmptyEntries)
                            .Select(p => p.Trim())
                            .ToArray();

            if (parts.Length < 2)
            {
                StatusMessage = "Invalid level line: expected Side,Cell;vehicle;vehicle;...";
                return;
            }

            var (prefix, validCells, _, _) = GetGridRenderInfo();

            var exitTokens = parts[0].Split(',', StringSplitOptions.RemoveEmptyEntries)
                                     .Select(t => t.Trim())
                                     .ToArray();

            if (exitTokens.Length != 2)
            {
                StatusMessage = "Exit must be in format: Side,Cell (ex: A,1A)";
                return;
            }

            ExitSide = char.ToUpperInvariant(exitTokens[0][0]);
            string exitCellLabel = exitTokens[1].ToUpper();

            if (!validCells.Contains(exitCellLabel))
            {
                StatusMessage = $"Exit cell '{exitCellLabel}' is not valid for {SelectedDifficulty}.";
                return;
            }

            ExitCellKey = prefix + exitCellLabel;

            for (int p = 1; p < parts.Length; p++)
            {
                var tokens = parts[p].Split(',', StringSplitOptions.RemoveEmptyEntries)
                                     .Select(t => t.Trim())
                                     .ToArray();

                if (tokens.Length != 4)
                {
                    StatusMessage = $"Vehicle must be Type,Color,Start,End. Bad: '{parts[p]}'";
                    return;
                }

                char type = ParseType(tokens[0]);
                char color = ParseColor(tokens[1]);
                string start = tokens[2].ToUpper();
                string end = tokens[3].ToUpper();

                if (!validCells.Contains(start) || !validCells.Contains(end))
                {
                    StatusMessage = $"Invalid start/end: {start} -> {end}.";
                    return;
                }

                var occupiedLabels = BuildOccupiedCellsFromStartEnd(start, end);
                if (occupiedLabels == null || occupiedLabels.Count == 0)
                {
                    StatusMessage = $"Start/end must be same row or column: {start} -> {end}.";
                    return;
                }

                int expectedLen = ExpectedLength(type);
                if (expectedLen > 0 && occupiedLabels.Count != expectedLen)
                {
                    StatusMessage = $"Vehicle {type} expected len {expectedLen} but got {occupiedLabels.Count}.";
                    return;
                }

                var occupiedKeys = occupiedLabels.Select(lbl => prefix + lbl).ToList();

                var allOccupied = Vehicles.SelectMany(v => v.Cells).ToHashSet();
                if (occupiedKeys.Any(allOccupied.Contains))
                {
                    StatusMessage = $"Collision: vehicle {type} overlaps another.";
                    return;
                }

                Vehicles.Add(new Vehicle
                {
                    Type = type,
                    Color = color,
                    Cells = occupiedKeys
                });
            }

            StatusMessage = $"Loaded level: vehicles={Vehicles.Count}.";
        }
        catch (Exception ex)
        {
            StatusMessage = $"Parse error: {ex.Message}";
        }
    }

    private void SelectVehicleByIndex(int idx)
    {
        if (GameWon) return;
        if (idx < 0 || idx >= Vehicles.Count) return;

        SelectedVehicleIndex = idx;
        StatusMessage = $"Selected: {Vehicles[idx].Type} ({Vehicles[idx].Color})";
    }

    private void SelectVehicleAtCell(string cellKey)
    {
        if (GameWon) return;

        for (int i = 0; i < Vehicles.Count; i++)
        {
            if (Vehicles[i].Cells.Contains(cellKey))
            {
                SelectVehicleByIndex(i);
                return;
            }
        }

        SelectedVehicleIndex = null;
        StatusMessage = "Selected: (none)";
    }

    private void MoveSelectedLeft() => MoveSelected(dx: -1, dy: 0);
    private void MoveSelectedRight() => MoveSelected(dx: +1, dy: 0);
    private void MoveSelectedUp() => MoveSelected(dx: 0, dy: -1);
    private void MoveSelectedDown() => MoveSelected(dx: 0, dy: +1);

    private void MoveSelected(int dx, int dy)
    {
        if (!HasSelection || GameWon) return;

        var (prefix, validCells, _, _) = GetGridRenderInfo();
        var v = Vehicles[SelectedVehicleIndex!.Value];

        var labels = v.Cells.Select(k => StripPrefix(k, prefix)).ToList();
        var orientation = GetOrientationFromStartEnd(labels);

        if (orientation == Orientation.Horizontal && dy != 0)
        {
            StatusMessage = "Blocked: horizontal vehicles only move left/right.";
            return;
        }

        if (orientation == Orientation.Vertical && dx != 0)
        {
            StatusMessage = "Blocked: vertical vehicles only move up/down.";
            return;
        }

        bool anyOutOfBounds = false;
        var movedLabels = new List<string>(labels.Count);

        foreach (var lbl in labels)
        {
            var (r, c) = ParseCell(lbl);
            int nr = r + dy;
            int nc = c + dx;
            var newLbl = ToCell(nr, nc);

            if (!validCells.Contains(newLbl))
                anyOutOfBounds = true;

            movedLabels.Add(newLbl);
        }

        if (anyOutOfBounds)
        {
            if (TryWinByExiting(v, labels, dx, dy, prefix))
            {
                GameWon = true;
                StatusMessage = "You win! Press Play Again to reset.";
                SelectedVehicleIndex = null;
                return;
            }

            StatusMessage = "Blocked: out of bounds.";
            return;
        }

        var movedKeys = movedLabels.Select(l => prefix + l).ToList();

        if (!IsMoveCollisionFree(SelectedVehicleIndex.Value, movedKeys))
        {
            StatusMessage = "Blocked: another vehicle is in the way.";
            return;
        }

        v.Cells = movedKeys;
        StatusMessage = "Moved.";
    }

    private bool TryWinByExiting(Vehicle v, List<string> currentLabels, int dx, int dy, string prefix)
    {
        if (v.Type != 'P') return false;
        if (!ExitSide.HasValue || ExitCellKey == null) return false;

        bool movingOut =
            (ExitSide.Value == 'A' && dx == -1 && dy == 0) ||
            (ExitSide.Value == 'C' && dx == +1 && dy == 0) ||
            (ExitSide.Value == 'B' && dx == 0 && dy == -1) ||
            (ExitSide.Value == 'D' && dx == 0 && dy == +1);

        if (!movingOut) return false;

        var orientation = GetOrientationFromStartEnd(currentLabels);
        bool orientedForExit =
            ((ExitSide.Value == 'A' || ExitSide.Value == 'C') && orientation == Orientation.Horizontal) ||
            ((ExitSide.Value == 'B' || ExitSide.Value == 'D') && orientation == Orientation.Vertical);

        if (!orientedForExit) return false;

        string exitLabel = StripPrefix(ExitCellKey, prefix);
        if (!currentLabels.Contains(exitLabel)) return false;

        string edgeMost = GetEdgeMostCellInDirection(currentLabels, dx, dy);
        if (edgeMost != exitLabel) return false;

        int size = GetSizeForDifficulty();
        var (er, ec) = ParseCell(exitLabel);

        bool exitOnEdge =
            (ExitSide.Value == 'A' && ec == 0) ||
            (ExitSide.Value == 'C' && ec == size - 1) ||
            (ExitSide.Value == 'B' && er == 1) ||
            (ExitSide.Value == 'D' && er == size);

        return exitOnEdge;
    }

    private static string GetEdgeMostCellInDirection(List<string> labels, int dx, int dy)
    {
        var coords = labels.Select(lbl => (lbl, rc: ParseCell(lbl))).ToList();

        if (dx == -1) return coords.OrderBy(x => x.rc.col).First().lbl;
        if (dx == +1) return coords.OrderByDescending(x => x.rc.col).First().lbl;
        if (dy == -1) return coords.OrderBy(x => x.rc.row).First().lbl;
        return coords.OrderByDescending(x => x.rc.row).First().lbl;
    }

    private int GetSizeForDifficulty() => SelectedDifficulty switch
    {
        "Easy" => 4,
        "Medium" => 5,
        "Hard" => 6,
        _ => 4
    };

    private void RotateSelectedCounterClockwise() => RotateSelected(isClockwise: false);
    private void RotateSelectedClockwise() => RotateSelected(isClockwise: true);

    private void RotateSelected(bool isClockwise)
    {
        if (!HasSelection || GameWon) return;

        var (prefix, validCells, _, _) = GetGridRenderInfo();
        var v = Vehicles[SelectedVehicleIndex!.Value];

        var oldLabels = v.Cells.Select(k => StripPrefix(k, prefix)).ToList();
        if (oldLabels.Count < 2)
        {
            StatusMessage = "Rotate blocked: length must be >= 2.";
            return;
        }

        string pivotLabel = oldLabels[0];
        var (pr, pc) = ParseCell(pivotLabel);

        var newLabels = new List<string>(oldLabels.Count);

        foreach (var lbl in oldLabels)
        {
            var (r, c) = ParseCell(lbl);
            int dr = r - pr;
            int dc = c - pc;

            int ndr, ndc;

            if (isClockwise)
            {
                ndr = dc;
                ndc = -dr;
            }
            else
            {
                ndr = -dc;
                ndc = dr;
            }

            int nr = pr + ndr;
            int nc = pc + ndc;

            newLabels.Add(ToCell(nr, nc));
        }

        foreach (var lbl in newLabels)
        {
            if (!validCells.Contains(lbl))
            {
                StatusMessage = "Rotate blocked: out of bounds.";
                return;
            }
        }

        var newKeys = newLabels.Select(l => prefix + l).ToList();

        if (!IsMoveCollisionFree(SelectedVehicleIndex.Value, newKeys))
        {
            StatusMessage = "Rotate blocked: destination occupied.";
            return;
        }

        if (!IsRotationSweepClear(SelectedVehicleIndex.Value, prefix, oldLabels, newLabels))
        {
            StatusMessage = "Rotate blocked: swing path occupied.";
            return;
        }

        v.Cells = newKeys;
        StatusMessage = isClockwise ? "Rotated CW." : "Rotated CCW.";
    }

    private bool IsRotationSweepClear(int movingIndex, string prefix, List<string> oldLabels, List<string> newLabels)
    {
        var occupied = new HashSet<string>();
        for (int i = 0; i < Vehicles.Count; i++)
        {
            if (i == movingIndex) continue;
            foreach (var k in Vehicles[i].Cells)
                occupied.Add(k);
        }

        var pivot = oldLabels[0];

        for (int i = 1; i < oldLabels.Count; i++)
        {
            var (or, oc) = ParseCell(oldLabels[i]);
            var (nr, nc) = ParseCell(newLabels[i]);

            int rMin = Math.Min(or, nr);
            int rMax = Math.Max(or, nr);
            int cMin = Math.Min(oc, nc);
            int cMax = Math.Max(oc, nc);

            for (int r = rMin; r <= rMax; r++)
            {
                for (int c = cMin; c <= cMax; c++)
                {
                    var lbl = ToCell(r, c);
                    if (lbl == pivot) continue;

                    var key = prefix + lbl;
                    if (occupied.Contains(key))
                        return false;
                }
            }
        }

        return true;
    }

    private bool IsMoveCollisionFree(int movingIndex, List<string> newKeys)
    {
        var occupied = new HashSet<string>();
        for (int i = 0; i < Vehicles.Count; i++)
        {
            if (i == movingIndex) continue;
            foreach (var k in Vehicles[i].Cells)
                occupied.Add(k);
        }
        return !newKeys.Any(occupied.Contains);
    }

    private enum Orientation { Unknown, Horizontal, Vertical }

    private static Orientation GetOrientationFromStartEnd(List<string> labels)
    {
        if (labels.Count < 2) return Orientation.Unknown;

        var (r0, c0) = ParseCell(labels[0]);
        var (r1, c1) = ParseCell(labels[^1]);

        if (r0 == r1 && c0 != c1) return Orientation.Horizontal;
        if (c0 == c1 && r0 != r1) return Orientation.Vertical;
        return Orientation.Unknown;
    }

    private static char ParseType(string s)
    {
        if (string.IsNullOrWhiteSpace(s)) throw new Exception("Empty vehicle type.");
        char t = char.ToUpperInvariant(s.Trim()[0]);
        if (t is not ('C' or 'B' or 'T' or 'P')) throw new Exception($"Unknown vehicle type '{s}'. Use C,B,T,P.");
        return t;
    }

    private static char ParseColor(string s)
    {
        if (string.IsNullOrWhiteSpace(s)) throw new Exception("Empty color.");
        char c = char.ToUpperInvariant(s.Trim()[0]);
        if (c is not ('R' or 'G' or 'B' or 'Y')) throw new Exception($"Unknown color '{s}'. Use R,G,B,Y.");
        return c;
    }

    private static int ExpectedLength(char type) => type switch
    {
        'C' => 2,
        'B' => 3,
        'T' => 4,
        'P' => 2,
        _ => 0
    };

    private static List<string>? BuildOccupiedCellsFromStartEnd(string start, string end)
    {
        var (sr, sc) = ParseCell(start);
        var (er, ec) = ParseCell(end);

        if (sr == er && sc != ec)
        {
            int step = sc < ec ? 1 : -1;
            var list = new List<string>();
            for (int c = sc; c != ec + step; c += step)
                list.Add(ToCell(sr, c));
            return list;
        }

        if (sc == ec && sr != er)
        {
            int step = sr < er ? 1 : -1;
            var list = new List<string>();
            for (int r = sr; r != er + step; r += step)
                list.Add(ToCell(r, sc));
            return list;
        }

        if (sr == er && sc == ec)
            return new List<string> { start };

        return null;
    }

    private static (int row, int col) ParseCell(string cell)
    {
        cell = cell.Trim().ToUpper();
        string rowPart = cell[..^1];
        char colChar = cell[^1];

        if (!int.TryParse(rowPart, out int row)) throw new Exception($"Bad row in cell '{cell}'.");
        int col = colChar - 'A';
        return (row, col);
    }

    private static string ToCell(int row, int colIndex)
    {
        char col = (char)('A' + colIndex);
        return $"{row}{col}";
    }

    private static string StripPrefix(string key, string prefix)
    {
        if (key.StartsWith(prefix, StringComparison.Ordinal))
            return key.Substring(prefix.Length);
        return key;
    }

    private (string Prefix, List<string> Cells, int CellSizePx, int Cols) GetGridRenderInfo()
    {
        return SelectedDifficulty switch
        {
            "Easy" => ("E-", EasyCells, 75, 4),
            "Medium" => ("M-", MediumCells, 60, 5),
            "Hard" => ("H-", HardCells, 50, 6),
            _ => ("E-", EasyCells, 75, 4)
        };
    }

    private (int rowIndex, int colIndex) GetExitRowCol(string prefix)
    {
        if (ExitCellKey == null) return (-1, -1);
        if (!ExitCellKey.StartsWith(prefix, StringComparison.Ordinal)) return (-1, -1);

        string label = ExitCellKey.Substring(prefix.Length);
        var (row, col) = ParseCell(label);
        return (row - 1, col);
    }

    private RenderFragment RenderGrid() => builder =>
{
    var (prefix, cells, _, _) = GetGridRenderInfo();
    int seq = 0;

    foreach (var cell in cells)
    {
        var key = prefix + cell;
        bool isExit = (ExitCellKey == key);

        var (row, col) = ParseCell(cell);          // row is 1-based, col is 0-based
        int gridRow = row;                         // CSS grid row line
        int gridCol = col + 1;                     // CSS grid col line is 1-based

        string classes = "cell";
        if (isExit && ExitSide.HasValue) classes += " exit exit-" + ExitSide.Value;

        string style = $"grid-row:{gridRow}; grid-column:{gridCol};";

        builder.OpenElement(seq++, "div");
        builder.AddAttribute(seq++, "class", classes);
        builder.AddAttribute(seq++, "style", style);
        builder.AddAttribute(seq++, "id", key);
        builder.AddAttribute(seq++, "role", "button");
        builder.AddAttribute(seq++, "tabindex", "0");
        builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => SelectVehicleAtCell(key)));
        builder.AddContent(seq++, cell);
        builder.CloseElement();
    }
};

private RenderFragment RenderVehicleSprites() => builder =>
{
    var (prefix, _, cellSize, _) = GetGridRenderInfo();
    int seq = 0;

    for (int i = 0; i < Vehicles.Count; i++)
    {
        var v = Vehicles[i];
        if (v.Cells.Count == 0) continue;

        var labels = v.Cells.Select(k => StripPrefix(k, prefix)).ToList();
        int len = labels.Count;

        var coords = labels.Select(ParseCell).ToList();
        int minRow = coords.Min(rc => rc.row);
        int maxRow = coords.Max(rc => rc.row);
        int minCol = coords.Min(rc => rc.col);
        int maxCol = coords.Max(rc => rc.col);

        int angle = GetAngleFromPivotToNext(labels);

        int gridColStart = minCol + 1;
        int gridColEnd = maxCol + 2;

        int gridRowStart = minRow;
        int gridRowEnd = maxRow + 1;

        string containerStyle =
            $"grid-column:{gridColStart} / {gridColEnd};" +
            $"grid-row:{gridRowStart} / {gridRowEnd};";

        int innerW = cellSize;
        int innerH = len * cellSize;

        string imgStyle =
            $"position:absolute; left:50%; top:50%;" +
            $"width:{innerW}px; height:{innerH}px;" +
            $"transform: translate(-50%,-50%) rotate({angle}deg);" +
            $"transform-origin: center center;";

        string classes = "veh-sprite";
        if (HasSelection && SelectedVehicleIndex!.Value == i) classes += " selected";

        builder.OpenElement(seq++, "div");
        builder.AddAttribute(seq++, "class", classes);
        builder.AddAttribute(seq++, "style", containerStyle);
        builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => SelectVehicleByIndex(i)));

        builder.OpenElement(seq++, "img");
builder.AddAttribute(seq++, "class", "veh-img");
builder.AddAttribute(seq++, "src", GetSpritePath(v));
builder.AddAttribute(seq++, "style", imgStyle);
builder.AddAttribute(seq++, "draggable", "false");
builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => SelectVehicleByIndex(i)));
        builder.CloseElement();

        builder.CloseElement();
    }
};

private static int GetAngleFromPivotToNext(List<string> labels)
{
    if (labels.Count < 2) return 0;

    var (r0, c0) = ParseCell(labels[0]);
    var (r1, c1) = ParseCell(labels[1]);

    int dr = r1 - r0;
    int dc = c1 - c0;

    if (dr == 1 && dc == 0) return 0;
    if (dr == 0 && dc == 1) return 90;
    if (dr == -1 && dc == 0) return 180;
    if (dr == 0 && dc == -1) return 270;

    return 0;
}

    private static string GetSpritePath(Vehicle v)
    {
        if (v.Type == 'P')
            return "/img/yellow-car.png";

        string color = v.Color switch
        {
            'R' => "red",
            'G' => "green",
            'B' => "blue",
            'Y' => "yellow",
            _ => "red"
        };

        string kind = v.Type switch
        {
            'C' => "car",
            'B' => "bus",
            'T' => "truck",
            _ => "car"
        };

        return $"/img/{color}-{kind}.png";
    }

    private static List<string> BuildCells(int rows, int cols)
    {
        var list = new List<string>(rows * cols);
        for (int r = 1; r <= rows; r++)
            for (int c = 0; c < cols; c++)
                list.Add($"{r}{(char)('A' + c)}");
        return list;
    }

    private class Vehicle
    {
        public char Type { get; set; }
        public char Color { get; set; }
        public List<string> Cells { get; set; } = new();
    }
}

<style>
    .controls {
        margin-bottom: 14px;
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
    }

    .selected-info {
        margin-left: 8px;
        font-weight: 600;
    }

    .status {
        margin-bottom: 10px;
        font-weight: 600;
    }

    .status.win {
        font-size: 18px;
    }

    .board {
        width: fit-content;
        height: fit-content;
    }

    .grid-container {
        width: fit-content;
        position: relative;
        gap: 0;
        border: 1px solid #000;
        background: white;
        box-sizing: border-box;
        position: relative;
        isolation: isolate;
        grid-auto-flow: row;
    }

    .cell {
        border: 1px solid #333;
        background-color: #a1e9ed;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        position: relative;
        user-select: none;
        box-sizing: border-box;
        cursor: pointer;
        z-index: 1;
    }
.veh-sprite {
    position: relative;
    z-index: 5;
    pointer-events: auto;
    cursor: pointer;
    user-select: none;
    overflow: visible;
    background: transparent;
}

    .veh-sprite.selected {
        outline: 4px solid rgba(0,0,0,0.55);
        outline-offset: -4px;
    }

.veh-img {
    object-fit: contain;
    image-rendering: pixelated;
    user-select: none;
    pointer-events: auto;
    display: block;
    z-index: 2;
}

    .cell.exit.exit-A { border-left-color: white; }
    .cell.exit.exit-B { border-top-color: white; }
    .cell.exit.exit-C { border-right-color: white; }
    .cell.exit.exit-D { border-bottom-color: white; }

    .grid-container.exit-B::before,
    .grid-container.exit-D::before {
        content: "";
        position: absolute;
        left: calc(var(--exit-col) * var(--cell-size));
        width: var(--cell-size);
        height: 4px;
        background: white;
        pointer-events: none;
        z-index: 10;
    }

    .grid-container.exit-B::before { top: -2px; }
    .grid-container.exit-D::before { bottom: -2px; }

    .grid-container.exit-A::before,
    .grid-container.exit-C::before {
        content: "";
        position: absolute;
        top: calc(var(--exit-row) * var(--cell-size));
        height: var(--cell-size);
        width: 4px;
        background: white;
        pointer-events: none;
        z-index: 10;
    }

    .grid-container.exit-A::before { left: -2px; }
    .grid-container.exit-C::before { right: -2px; }
</style>