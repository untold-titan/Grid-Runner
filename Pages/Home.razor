@page "/"

<PageTitle>Home</PageTitle>

<h1>Grid Test (File-driven)</h1>

<div class="controls">
    <label>
        Difficulty:
        <select @bind="SelectedDifficulty">
            <option value="Easy">Easy (4x4)</option>
            <option value="Medium">Medium (5x5)</option>
            <option value="Hard">Hard (6x6)</option>
        </select>
    </label>

    <button @onclick="PlayRandomUnplayed" disabled="@GameWon">Play</button>
    <button @onclick="ClearLevel">Clear</button>

    @if (GameWon)
    {
        <button @onclick="PlayAgain">Play Again</button>
        <button @onclick="PlayNextLevel">Play Next Level</button>
    }
</div>

<div class="controls">
    <button @onclick="MoveSelectedUp" disabled="@(!HasSelection || GameWon)">Up</button>
    <button @onclick="MoveSelectedDown" disabled="@(!HasSelection || GameWon)">Down</button>
    <button @onclick="MoveSelectedLeft" disabled="@(!HasSelection || GameWon)">Left</button>
    <button @onclick="MoveSelectedRight" disabled="@(!HasSelection || GameWon)">Right</button>
    <button @onclick="RotateSelectedCounterClockwise" disabled="@(!HasSelection || GameWon)">Rotate CCW</button>
    <button @onclick="RotateSelectedClockwise" disabled="@(!HasSelection || GameWon)">Rotate CW</button>

    <span class="selected-info">
        @if (HasSelection)
        {
            <span>Selected: @SelectedVehicleDisplay</span>
        }
        else
        {
            <span>Selected: (none) — click a vehicle on the grid</span>
        }
    </span>
</div>

@if (!string.IsNullOrWhiteSpace(StatusMessage))
{
    <div class="status @(GameWon ? "win" : "")">@StatusMessage</div>
}

@if (CurrentLevelIndex.HasValue)
{
    <div style="font-weight:600; margin-bottom:6px;">
        Level Index: @(CurrentLevelIndex + 1)
    </div>
}

@{
    var (prefix, _, cellSizePx, cols) = GetGridRenderInfo();
    var (exitRow, exitCol) = GetExitRowCol(prefix);
    string exitClass = ExitSide.HasValue ? $"exit-{ExitSide.Value}" : "";

    string gridStyle =
        $"--cell-size:{cellSizePx}px;" +
        $"--cols:{cols};" +
        $"--exit-row:{exitRow};" +
        $"--exit-col:{exitCol};" +
        $"display:grid; grid-template-columns:repeat({cols},{cellSizePx}px);" +
        $"grid-auto-rows:{cellSizePx}px;";
}

<div class="grid-container @GridCssClass @exitClass" style="@gridStyle">
    @RenderGrid()
</div>

@code {
    private string SelectedDifficulty = "Easy";
    private string StatusMessage = "";

    private char? ExitSide;
    private string? ExitCellKey;

    private string? _queueDifficulty;

    private readonly List<Vehicle> Vehicles = new();

    private int? SelectedVehicleIndex;
    private bool HasSelection => SelectedVehicleIndex.HasValue && SelectedVehicleIndex.Value >= 0 && SelectedVehicleIndex.Value < Vehicles.Count;
    private string SelectedVehicleDisplay => HasSelection
        ? $"{Vehicles[SelectedVehicleIndex!.Value].Type} ({Vehicles[SelectedVehicleIndex!.Value].Color})"
        : "(none)";

    private bool GameWon = false;
    private string? LastLevelLine;

    private readonly List<string> EasyCells = BuildCells(4, 4);
    private readonly List<string> MediumCells = BuildCells(5, 5);
    private readonly List<string> HardCells = BuildCells(6, 6);

    private string GridCssClass => SelectedDifficulty switch
    {
        "Easy" => "easy",
        "Medium" => "medium",
        "Hard" => "hard",
        _ => "easy"
    };

    private void LoadSampleLine()
    {
        string sample = "A,1A;P,R,3C,4C;C,B,2A,2B;C,G,3A,4A;T,Y,1D,4D";
        LoadLevelLine(sample);
    }

    private void PlayAgain()
    {
        if (!string.IsNullOrWhiteSpace(LastLevelLine))
            LoadLevelLine(LastLevelLine!);
        else
            ClearLevel();
    }

    private void PlayNextLevel() {
        PlayRandomUnplayed();
    }

    private void ClearLevel()
    {
        Vehicles.Clear();
        ExitSide = null;
        ExitCellKey = null;
        SelectedVehicleIndex = null;
        GameWon = false;
        StatusMessage = "Cleared.";
    }

    private static readonly List<string> EasyLevelLines = new() {
    "C,2D;P,Y,2A,2B;C,R,1C,2C;C,G,3B,3C;C,B,4C,4D",
    "C,3D;P,Y,3A,3B;C,R,2C,3C;C,G,1B,1C;C,B,1D,2D",
    "A,2A;P,Y,2C,2D;C,R,1B,2B;C,G,1C,1D;C,B,4C,4D",
    "B,1C;P,Y,2C,3C;C,R,1B,1C;C,G,3A,4A;C,B,4B,4C",
    "D,4B;P,Y,2B,3B;C,R,4A,4B;C,G,1D,2D;C,B,1A,1B",
    "C,1D;P,Y,1A,1B;C,R,1C,2C;C,G,3A,3B;C,B,4B,4C",
    "A,4A;P,Y,4C,4D;C,R,3B,4B;C,G,2C,2D;C,B,1A,2A",
    "B,1A;P,Y,3A,4A;C,R,2A,2B;C,G,1C,2C;C,B,4C,4D",
    "D,4D;P,Y,2D,3D;C,R,4C,4D;C,G,1B,2B;C,B,3A,3B",
    "C,4D;P,Y,4A,4B;C,R,3C,4C;C,G,2B,2C;C,B,1D,2D",
    };

    private static readonly List<string> MediumLevelLines = new() {
    "C,3E;P,Y,3B,3C;C,R,2D,3D;C,G,1C,1D;B,B,1A,3A;C,B,4C,4D;T,R,5B,5E",
    "C,2E;P,Y,2B,2C;C,R,1D,2D;C,G,3C,4C;B,B,3A,5A;C,B,4D,5D;T,G,1A,1D",
    "C,4E;P,Y,4B,4C;C,R,3D,4D;C,G,2C,2D;B,B,1A,3A;C,B,5C,5D;T,R,1B,1E",
    "C,3E;P,Y,3B,3C;C,R,3D,4D;C,G,1B,1C;B,B,2A,4A;C,B,5B,5C;T,G,1D,4D",
    "C,2E;P,Y,2B,2C;C,R,2D,3D;C,G,4B,4C;B,B,1A,3A;C,B,5C,5D;T,R,4D,4A",
    "C,3E;P,Y,3B,3C;C,R,2D,3D;C,G,4C,5C;B,B,1B,3B;C,B,1D,1E;T,G,5A,5D",
    "C,4E;P,Y,4B,4C;C,R,4D,5D;C,G,2B,3B;B,B,1A,3A;C,B,1D,2D;T,R,5A,5D",
    "C,3E;P,Y,3B,3C;C,R,1D,2D;C,G,4D,5D;B,B,2A,4A;C,B,5B,5C;T,G,1A,1D",
    "C,2E;P,Y,2B,2C;C,R,3D,4D;C,G,1C,1D;B,B,3A,5A;C,B,4B,4C;T,R,5B,5E",
    "C,4E;P,Y,4B,4C;C,R,2D,3D;C,G,1B,1C;B,B,2A,4A;C,B,5D,5E;T,G,5A,5D",
    };

    private static readonly List<string> HardLevelLines = new() {    
    "C,3F;P,Y,3C,3D;C,R,2E,3E;C,G,4D,4E;B,B,1B,3B;T,R,6A,6D;B,G,4A,6A;C,B,5E,5F",
    "C,4F;P,Y,4C,4D;C,R,3E,4E;C,G,2C,2D;B,B,1A,3A;T,G,6B,6E;B,R,2F,4F;C,B,5C,5D",
    "C,2F;P,Y,2C,2D;C,R,2E,3E;C,G,4B,4C;B,B,1D,3D;T,R,6A,6D;B,G,3A,5A;C,B,5E,5F;C,R,1A,1B",
    "C,3F;P,Y,3C,3D;C,R,1E,2E;C,G,4E,5E;B,B,2B,4B;T,G,6C,6F;B,R,1A,3A;C,B,5C,5D",
    "C,4F;P,Y,4C,4D;C,R,4E,5E;C,G,2D,3D;B,B,1B,3B;T,R,6A,6D;B,G,3A,5A;C,B,2F,3F;C,R,1E,1F",
    "C,2F;P,Y,2C,2D;C,R,3D,4D;C,G,1C,1D;B,B,4A,6A;T,G,6B,6E;B,R,1E,3E;C,B,5C,5D",
    "C,3F;P,Y,3C,3D;C,R,2E,3E;C,G,5B,5C;B,B,1B,3B;T,R,6A,6D;B,G,3A,5A;C,B,4D,4E;C,R,1F,2F",
    "C,4F;P,Y,4C,4D;C,R,3C,3D;C,G,2E,3E;B,B,1A,3A;T,G,6B,6E;B,R,4A,6A;C,B,5D,5E",
    "C,2F;P,Y,2C,2D;C,R,2E,3E;C,G,4C,4D;B,B,1D,3D;T,R,6A,6D;B,G,3A,5A;C,B,5E,5F",
    "C,3F;P,Y,3C,3D;C,R,4D,5D;C,G,2B,2C;B,B,1B,3B;T,G,6C,6F;B,R,2E,4E;C,B,5A,5B;C,R,1E,1F",
    };

    private readonly Random _rng = new();
    private List<string> _currentPack = new();
 private Queue<(string line, int index)> _playQueue = new();

    private void EnsurePackLoadedForDifficulty() {
        _currentPack = SelectedDifficulty switch {
            "Easy" => EasyLevelLines,
            "Medium" => MediumLevelLines,
            "Hard" => HardLevelLines,
            _ => EasyLevelLines
        };

        if (_queueDifficulty != SelectedDifficulty) {
            _queueDifficulty = SelectedDifficulty;
            RefillAndShuffleQueue();
            return;
        }

        if (_playQueue.Count == 0) RefillAndShuffleQueue();
    }

    private int? CurrentLevelIndex = null;

private void RefillAndShuffleQueue()
{
    // Pair each level string with its original index in the pack
    var indexed = _currentPack
        .Select((line, index) => (line, index))
        .ToList();

    // Shuffle the list in-place (Fisher–Yates)
    for (int i = indexed.Count - 1; i > 0; i--)
    {
        int j = _rng.Next(i + 1);
        (indexed[i], indexed[j]) = (indexed[j], indexed[i]);
    }

    // Keep both the shuffled lines and their original indices
    _playQueue = new Queue<(string line, int index)>(indexed);
}

private void PlayRandomUnplayed()
{
    EnsurePackLoadedForDifficulty();

    if (_playQueue.Count == 0)
        RefillAndShuffleQueue();

    var next = _playQueue.Dequeue();
    CurrentLevelIndex = next.index;

    LoadLevelLine(next.line);
}

    private void LoadLevelLine(string line) {
        try {
            Vehicles.Clear();
            ExitSide = null;
            ExitCellKey = null;
            SelectedVehicleIndex = null;
            GameWon = false;
            StatusMessage = "";

            LastLevelLine = line;

            var parts = line.Split(';', StringSplitOptions.RemoveEmptyEntries)
                            .Select(p => p.Trim())
                            .ToArray();

            if (parts.Length < 2)
            {
                StatusMessage = "Invalid level line: expected Side,Cell;vehicle;vehicle;...";
                return;
            }

            var (prefix, validCells, _, _) = GetGridRenderInfo();

            var exitTokens = parts[0].Split(',', StringSplitOptions.RemoveEmptyEntries)
                                     .Select(t => t.Trim())
                                     .ToArray();

            if (exitTokens.Length != 2)
            {
                StatusMessage = "Exit must be in format: Side,Cell (ex: A,1A)";
                return;
            }

            ExitSide = char.ToUpperInvariant(exitTokens[0][0]);
            string exitCellLabel = exitTokens[1].ToUpper();

            if (!validCells.Contains(exitCellLabel))
            {
                StatusMessage = $"Exit cell '{exitCellLabel}' is not valid for {SelectedDifficulty}.";
                return;
            }

            ExitCellKey = prefix + exitCellLabel;

            for (int p = 1; p < parts.Length; p++)
            {
                var tokens = parts[p].Split(',', StringSplitOptions.RemoveEmptyEntries)
                                     .Select(t => t.Trim())
                                     .ToArray();

                if (tokens.Length != 4)
                {
                    StatusMessage = $"Vehicle section must be exactly 4 tokens: Type,Color,Start,End. Bad section: '{parts[p]}'";
                    return;
                }

                char type = ParseType(tokens[0]);
                char color = ParseColor(tokens[1]);
                string start = tokens[2].ToUpper();
                string end = tokens[3].ToUpper();

                if (!validCells.Contains(start) || !validCells.Contains(end))
                {
                    StatusMessage = $"Vehicle has invalid start/end cell: {start} -> {end}.";
                    return;
                }

                var occupiedLabels = BuildOccupiedCellsFromStartEnd(start, end);
                if (occupiedLabels == null || occupiedLabels.Count == 0)
                {
                    StatusMessage = $"Vehicle start/end must be in same row or same column: {start} -> {end}.";
                    return;
                }

                int expectedLen = ExpectedLength(type);
                if (expectedLen > 0 && occupiedLabels.Count != expectedLen)
                {
                    StatusMessage = $"Vehicle {type} expected length {expectedLen} but got {occupiedLabels.Count} from {start}->{end}.";
                    return;
                }

                var occupiedKeys = occupiedLabels.Select(lbl => prefix + lbl).ToList();

                var allOccupied = Vehicles.SelectMany(v => v.Cells).ToHashSet();
                if (occupiedKeys.Any(allOccupied.Contains))
                {
                    StatusMessage = $"Collision: vehicle {type} overlaps an existing vehicle.";
                    return;
                }

                Vehicles.Add(new Vehicle
                {
                    Type = type,
                    Color = color,
                    CssClass = CssClassForColor(color),
                    Cells = occupiedKeys
                });
            }

            StatusMessage = $"Loaded level: vehicles={Vehicles.Count}.";
        }
        catch (Exception ex)
        {
            StatusMessage = $"Parse error: {ex.Message}";
        }
    }

    private void SelectVehicleAtCell(string cellKey)
    {
        if (GameWon) return;

        for (int i = 0; i < Vehicles.Count; i++)
        {
            if (Vehicles[i].Cells.Contains(cellKey))
            {
                SelectedVehicleIndex = i;
                StatusMessage = $"Selected: {Vehicles[i].Type} ({Vehicles[i].Color})";
                return;
            }
        }

        SelectedVehicleIndex = null;
        StatusMessage = "Selected: (none)";
    }

    private void MoveSelectedLeft() => MoveSelected(dx: -1, dy: 0);
    private void MoveSelectedRight() => MoveSelected(dx: +1, dy: 0);
    private void MoveSelectedUp() => MoveSelected(dx: 0, dy: -1);
    private void MoveSelectedDown() => MoveSelected(dx: 0, dy: +1);

    private void MoveSelected(int dx, int dy)
    {
        if (!HasSelection || GameWon) return;

        var (prefix, validCells, _, _) = GetGridRenderInfo();
        var v = Vehicles[SelectedVehicleIndex!.Value];

        var labels = v.Cells.Select(k => StripPrefix(k, prefix)).ToList();
        var orientation = GetOrientation(labels);

        if (orientation == Orientation.Horizontal && dy != 0)
        {
            StatusMessage = "Blocked: horizontal vehicles can only move left/right.";
            return;
        }

        if (orientation == Orientation.Vertical && dx != 0)
        {
            StatusMessage = "Blocked: vertical vehicles can only move up/down.";
            return;
        }

        bool anyOutOfBounds = false;
        var movedLabels = new List<string>(labels.Count);

        foreach (var lbl in labels)
        {
            var (r, c) = ParseCell(lbl);
            int nr = r + dy;
            int nc = c + dx;
            var newLbl = ToCell(nr, nc);

            if (!validCells.Contains(newLbl))
                anyOutOfBounds = true;

            movedLabels.Add(newLbl);
        }

        if (anyOutOfBounds)
        {
            if (TryWinByExiting(v, labels, dx, dy, prefix))
            {
                GameWon = true;
                StatusMessage = "You win! Press Play Again to reset.";
                SelectedVehicleIndex = null;
                return;
            }

            StatusMessage = "Blocked: out of bounds.";
            return;
        }

        var movedKeys = movedLabels.Select(l => prefix + l).ToList();

        if (!IsMoveCollisionFree(SelectedVehicleIndex.Value, movedKeys))
        {
            StatusMessage = "Blocked: another vehicle is in the way.";
            return;
        }

        v.Cells = movedKeys;
        StatusMessage = "Moved.";
    }

    private bool TryWinByExiting(Vehicle v, List<string> currentLabels, int dx, int dy, string prefix)
    {
        if (v.Type != 'P') return false;
        if (!ExitSide.HasValue || ExitCellKey == null) return false;

        bool movingOut =
            (ExitSide.Value == 'A' && dx == -1 && dy == 0) ||
            (ExitSide.Value == 'C' && dx == +1 && dy == 0) ||
            (ExitSide.Value == 'B' && dx == 0 && dy == -1) ||
            (ExitSide.Value == 'D' && dx == 0 && dy == +1);

        if (!movingOut) return false;

        var orientation = GetOrientation(currentLabels);
        bool orientedForExit =
            ((ExitSide.Value == 'A' || ExitSide.Value == 'C') && orientation == Orientation.Horizontal) ||
            ((ExitSide.Value == 'B' || ExitSide.Value == 'D') && orientation == Orientation.Vertical);

        if (!orientedForExit) return false;

        string exitLabel = StripPrefix(ExitCellKey, prefix);
        if (!currentLabels.Contains(exitLabel)) return false;

        string edgeMost = GetEdgeMostCellInDirection(currentLabels, dx, dy);
        if (edgeMost != exitLabel) return false;

        int size = GetSizeForDifficulty();
        var (er, ec) = ParseCell(exitLabel);

        bool exitOnEdge =
            (ExitSide.Value == 'A' && ec == 0) ||
            (ExitSide.Value == 'C' && ec == size - 1) ||
            (ExitSide.Value == 'B' && er == 1) ||
            (ExitSide.Value == 'D' && er == size);

        return exitOnEdge;
    }

    private static string GetEdgeMostCellInDirection(List<string> labels, int dx, int dy)
    {
        var coords = labels.Select(lbl => (lbl, rc: ParseCell(lbl))).ToList();

        if (dx == -1) return coords.OrderBy(x => x.rc.col).First().lbl;
        if (dx == +1) return coords.OrderByDescending(x => x.rc.col).First().lbl;
        if (dy == -1) return coords.OrderBy(x => x.rc.row).First().lbl;
        return coords.OrderByDescending(x => x.rc.row).First().lbl;
    }

    private int GetSizeForDifficulty() => SelectedDifficulty switch
    {
        "Easy" => 4,
        "Medium" => 5,
        "Hard" => 6,
        _ => 4
    };

    private void RotateSelectedCounterClockwise() => RotateSelected(isClockwise: false);
    private void RotateSelectedClockwise() => RotateSelected(isClockwise: true);

    private void RotateSelected(bool isClockwise)
    {
        if (!HasSelection || GameWon) return;

        var (prefix, validCells, _, _) = GetGridRenderInfo();
        var v = Vehicles[SelectedVehicleIndex!.Value];

        var oldLabels = v.Cells.Select(k => StripPrefix(k, prefix)).ToList();

        if (GetOrientation(oldLabels) == Orientation.Unknown)
        {
            StatusMessage = "Rotate blocked: not a straight vehicle.";
            return;
        }

        string pivotLabel = oldLabels[0];
        var (pr, pc) = ParseCell(pivotLabel);

        var newLabels = new List<string>(oldLabels.Count);

        foreach (var lbl in oldLabels)
        {
            var (r, c) = ParseCell(lbl);
            int dr = r - pr;
            int dc = c - pc;

            int ndr, ndc;

            if (isClockwise)
            {
                ndr = dc;
                ndc = -dr;
            }
            else
            {
                ndr = -dc;
                ndc = dr;
            }

            int nr = pr + ndr;
            int nc = pc + ndc;

            newLabels.Add(ToCell(nr, nc));
        }

        foreach (var lbl in newLabels)
        {
            if (!validCells.Contains(lbl))
            {
                StatusMessage = "Rotate blocked: out of bounds.";
                return;
            }
        }

        var newKeys = newLabels.Select(l => prefix + l).ToList();

        if (!IsMoveCollisionFree(SelectedVehicleIndex.Value, newKeys))
        {
            StatusMessage = "Rotate blocked: destination occupied.";
            return;
        }

        if (!IsRotationSweepClear(SelectedVehicleIndex.Value, prefix, oldLabels, newLabels))
        {
            StatusMessage = "Rotate blocked: swing path occupied.";
            return;
        }

        v.Cells = newKeys;
        StatusMessage = isClockwise ? "Rotated CW." : "Rotated CCW.";
    }

    private bool IsRotationSweepClear(int movingIndex, string prefix, List<string> oldLabels, List<string> newLabels)
    {
        var occupied = new HashSet<string>();
        for (int i = 0; i < Vehicles.Count; i++)
        {
            if (i == movingIndex) continue;
            foreach (var k in Vehicles[i].Cells)
                occupied.Add(k);
        }

        var pivot = oldLabels[0];

        for (int i = 1; i < oldLabels.Count; i++)
        {
            var (or, oc) = ParseCell(oldLabels[i]);
            var (nr, nc) = ParseCell(newLabels[i]);

            int rMin = Math.Min(or, nr);
            int rMax = Math.Max(or, nr);
            int cMin = Math.Min(oc, nc);
            int cMax = Math.Max(oc, nc);

            for (int r = rMin; r <= rMax; r++)
            {
                for (int c = cMin; c <= cMax; c++)
                {
                    var lbl = ToCell(r, c);
                    if (lbl == pivot) continue;

                    var key = prefix + lbl;
                    if (occupied.Contains(key))
                        return false;
                }
            }
        }

        return true;
    }

    private bool IsMoveCollisionFree(int movingIndex, List<string> newKeys)
    {
        var occupied = new HashSet<string>();
        for (int i = 0; i < Vehicles.Count; i++)
        {
            if (i == movingIndex) continue;
            foreach (var k in Vehicles[i].Cells)
                occupied.Add(k);
        }
        return !newKeys.Any(occupied.Contains);
    }

    private static string StripPrefix(string key, string prefix)
    {
        if (key.StartsWith(prefix, StringComparison.Ordinal))
            return key.Substring(prefix.Length);
        return key;
    }

    private enum Orientation { Unknown, Horizontal, Vertical }

    private static Orientation GetOrientation(List<string> labels)
    {
        var coords = labels.Select(ParseCell).ToList();
        bool sameRow = coords.All(x => x.row == coords[0].row);
        bool sameCol = coords.All(x => x.col == coords[0].col);

        if (sameRow && !sameCol) return Orientation.Horizontal;
        if (sameCol && !sameRow) return Orientation.Vertical;
        return Orientation.Unknown;
    }

    private static char ParseType(string s)
    {
        if (string.IsNullOrWhiteSpace(s)) throw new Exception("Empty vehicle type.");
        char t = char.ToUpperInvariant(s.Trim()[0]);
        if (t is not ('C' or 'B' or 'T' or 'P')) throw new Exception($"Unknown vehicle type '{s}'. Use C,B,T,P.");
        return t;
    }

    private static char ParseColor(string s)
    {
        if (string.IsNullOrWhiteSpace(s)) throw new Exception("Empty color.");
        char c = char.ToUpperInvariant(s.Trim()[0]);
        if (c is not ('R' or 'G' or 'B' or 'Y')) throw new Exception($"Unknown color '{s}'. Use R,G,B,Y.");
        return c;
    }

    private static int ExpectedLength(char type) => type switch
    {
        'C' => 2,
        'B' => 3,
        'T' => 4,
        'P' => 2,
        _ => 0
    };

    private static List<string>? BuildOccupiedCellsFromStartEnd(string start, string end)
    {
        var (sr, sc) = ParseCell(start);
        var (er, ec) = ParseCell(end);

        if (sr == er && sc != ec)
        {
            int step = sc < ec ? 1 : -1;
            var list = new List<string>();
            for (int c = sc; c != ec + step; c += step)
                list.Add(ToCell(sr, c));
            return list;
        }

        if (sc == ec && sr != er)
        {
            int step = sr < er ? 1 : -1;
            var list = new List<string>();
            for (int r = sr; r != er + step; r += step)
                list.Add(ToCell(r, sc));
            return list;
        }

        if (sr == er && sc == ec)
            return new List<string> { start };

        return null;
    }

    private static (int row, int col) ParseCell(string cell)
    {
        cell = cell.Trim().ToUpper();
        if (cell.Length < 2) throw new Exception($"Bad cell '{cell}'.");

        string rowPart = cell[..^1];
        char colChar = cell[^1];

        if (!int.TryParse(rowPart, out int row)) throw new Exception($"Bad row in cell '{cell}'.");
        if (colChar < 'A' || colChar > 'Z') throw new Exception($"Bad column in cell '{cell}'.");

        int col = colChar - 'A';
        return (row, col);
    }

    private static string ToCell(int row, int colIndex)
    {
        char col = (char)('A' + colIndex);
        return $"{row}{col}";
    }

    private (string Prefix, List<string> Cells, int CellSizePx, int Cols) GetGridRenderInfo()
    {
        return SelectedDifficulty switch
        {
            "Easy" => ("E-", EasyCells, 75, 4),
            "Medium" => ("M-", MediumCells, 60, 5),
            "Hard" => ("H-", HardCells, 50, 6),
            _ => ("E-", EasyCells, 75, 4)
        };
    }

    private (int rowIndex, int colIndex) GetExitRowCol(string prefix)
    {
        if (ExitCellKey == null) return (-1, -1);
        if (!ExitCellKey.StartsWith(prefix, StringComparison.Ordinal)) return (-1, -1);

        string label = ExitCellKey.Substring(prefix.Length);
        var (row, col) = ParseCell(label);
        return (row - 1, col);
    }

    private RenderFragment RenderGrid() => builder =>
    {
        var (prefix, cells, _, _) = GetGridRenderInfo();
        int seq = 0;

        var cellToVehicleIndex = new Dictionary<string, int>();
        for (int i = 0; i < Vehicles.Count; i++)
            foreach (var key in Vehicles[i].Cells)
                cellToVehicleIndex[key] = i;

        foreach (var cell in cells)
        {
            var key = prefix + cell;

            bool hasVehicle = cellToVehicleIndex.TryGetValue(key, out var vIndex);
            Vehicle? vehicle = hasVehicle ? Vehicles[vIndex] : null;

            bool isExit = (ExitCellKey == key);
            bool isSelected = HasSelection && hasVehicle && vIndex == SelectedVehicleIndex!.Value;

            string classes = "cell";
            if (vehicle != null) classes += " occupied " + vehicle.CssClass;
            if (isExit && ExitSide.HasValue) classes += " exit exit-" + ExitSide.Value;
            if (isSelected) classes += " selected";

            builder.OpenElement(seq++, "div");
            builder.AddAttribute(seq++, "class", classes);
            builder.AddAttribute(seq++, "id", key);
            builder.AddAttribute(seq++, "role", "button");
            builder.AddAttribute(seq++, "tabindex", "0");
            builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => SelectVehicleAtCell(key)));
            builder.AddContent(seq++, cell);

            if (vehicle != null && vehicle.Cells.Count > 0 && vehicle.Cells[0] == key)
            {
                builder.OpenElement(seq++, "div");
                builder.AddAttribute(seq++, "class", "veh-label");
                builder.AddContent(seq++, vehicle.Type.ToString());
                builder.CloseElement();
            }

            builder.CloseElement();
        }
    };

    private static string CssClassForColor(char color) => color switch
    {
        'R' => "veh-red",
        'G' => "veh-green",
        'B' => "veh-blue",
        'Y' => "veh-yellow",
        _ => "veh-red"
    };

    private static List<string> BuildCells(int rows, int cols)
    {
        var list = new List<string>(rows * cols);
        for (int r = 1; r <= rows; r++)
            for (int c = 0; c < cols; c++)
                list.Add($"{r}{(char)('A' + c)}");
        return list;
    }

    private class Vehicle
    {
        public char Type { get; set; }
        public char Color { get; set; }
        public string CssClass { get; set; } = "";
        public List<string> Cells { get; set; } = new();
    }
}

<style>
    .controls {
        margin-bottom: 14px;
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
    }

    .selected-info {
        margin-left: 8px;
        font-weight: 600;
    }

    .status {
        margin-bottom: 10px;
        font-weight: 600;
    }

    .status.win {
        font-size: 18px;
    }

    .grid-container {
        width: fit-content;
        position: relative;
        gap: 0;
        border: 1px solid #000;
        background: white;
        box-sizing: border-box;
    }

    .cell {
        border: 1px solid #333;
        background-color: #a1e9ed;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        position: relative;
        user-select: none;
        box-sizing: border-box;
        cursor: pointer;
    }

    .cell.selected {
        outline: 4px solid rgba(0,0,0,0.55);
        outline-offset: -4px;
    }

    .occupied.veh-red { background-color: #ff6b6b; }
    .occupied.veh-green { background-color: #5fe37a; }
    .occupied.veh-blue { background-color: #6ea8fe; }
    .occupied.veh-yellow { background-color: #ffe066; }

    .veh-label {
        position: absolute;
        bottom: 3px;
        right: 5px;
        font-size: 12px;
        opacity: 0.9;
        pointer-events: none;
    }

    .cell.exit.exit-A { border-left-color: white; }
    .cell.exit.exit-B { border-top-color: white; }
    .cell.exit.exit-C { border-right-color: white; }
    .cell.exit.exit-D { border-bottom-color: white; }

    .grid-container.exit-B::before,
    .grid-container.exit-D::before {
        content: "";
        position: absolute;
        left: calc(var(--exit-col) * var(--cell-size));
        width: var(--cell-size);
        height: 4px;
        background: white;
        pointer-events: none;
        z-index: 10;
    }

    .grid-container.exit-B::before { top: -2px; }
    .grid-container.exit-D::before { bottom: -2px; }

    .grid-container.exit-A::before,
    .grid-container.exit-C::before {
        content: "";
        position: absolute;
        top: calc(var(--exit-row) * var(--cell-size));
        height: var(--cell-size);
        width: 4px;
        background: white;
        pointer-events: none;
        z-index: 10;
    }

    .grid-container.exit-A::before { left: -2px; }
    .grid-container.exit-C::before { right: -2px; }
</style>
``