@page "/"
@using GridRunner.Blocks
@using GridRunner.Enums
@using GridRunner.Interfaces
@using GridRunner.Models
@using GridRunner.Services
@using GridRunner.Utilities
@inject IJSRuntime JS
@inject LevelLoaderService LevelLoader
@inject VehicleMovementService VehicleMovement
@inject BlockExecutionService BlockExecution

<PageTitle>Grid Runner</PageTitle>

<div class="controls">
    <label>
        Difficulty:
        <select @bind="SelectedDifficulty">
            <option value="Easy">Easy (4x4)</option>
            <option value="Medium">Medium (5x5)</option>
            <option value="Hard">Hard (6x6)</option>
        </select>
    </label>

    <button @onclick="PlayRandomUnplayed" disabled="@GameWon">Play</button>
    <button @onclick="ClearLevel">Clear</button>

    @if (GameWon)
    {
        <button @onclick="PlayAgain">Play Again</button>
        <button @onclick="PlayNextLevel">Play Next Level</button>
    }
</div>

<div class="controls">
    <button @onclick="RunBlockStacks" disabled="@(GameWon || IsExecuting)">Execute Blocks</button>
    <span class="selected-info">
        @if (HasSelection)
        {
            <span>Selected: @SelectedVehicleDisplay</span>
        }
        else
        {
            <span>Selected: (none)</span>
        }
    </span>
</div>

@if (!string.IsNullOrWhiteSpace(StatusMessage))
{
    <div class="status @(GameWon ? "win" : "")">@StatusMessage</div>
}

@if (CurrentLevelIndex.HasValue)
{
    <div style="font-weight:600; margin-bottom:6px;">
        Level Index: @(CurrentLevelIndex + 1)
    </div>
}

<div class="main-layout">
    <div class="panel">
        <details class="drop" open>
            <summary class="drop-title">Move</summary>
            <div class="drop-body">
                @foreach (var value in Enum.GetValues(typeof(MoveActionEnum)))
                {
                    <div class="panel-block"
                         @onpointerdown="(e) => OnPalettePointerDown(e, typeof(MoveBlock), (MoveActionEnum)value)">
                        <svg width="90" height="90" viewBox="0 0 92 92">
                            <path d="M 1 1 L 15 1 L 15 15 L 30 1 L 91 1 L 91 75 L 30 75 L 15 91 L 15 75 L 1 75 Z"
                                  fill="@PaletteGray" stroke="#000000" stroke-width="1" />
                            <text x="46" y="45" text-anchor="middle" font-size="14" font-weight="bold">@value.ToString()</text>
                        </svg>
                    </div>
                }
            </div>
        </details>

        <details class="drop" open>
            <summary class="drop-title">Rotate</summary>
            <div class="drop-body">
                @foreach (var value in Enum.GetValues(typeof(RotateActionEnum)))
                {
                    <div class="panel-block"
                         @onpointerdown="(e) => OnPalettePointerDown(e, typeof(RotateBlock), (RotateActionEnum)value)">
                        <svg width="90" height="90" viewBox="0 0 92 92">
                            <path d="M 1 1 L 15 1 L 15 15 L 30 1 L 91 1 L 91 75 L 30 75 L 15 91 L 15 75 L 1 75 Z"
                                  fill="@PaletteGray" stroke="#000000" stroke-width="1" />
                            <text x="46" y="45" text-anchor="middle" font-size="12" font-weight="bold">@(value.ToString() == "Clockwise" ? "CW" : "CCW")</text>
                        </svg>
                    </div>
                }
            </div>
        </details>

        <details class="drop" open>
            <summary class="drop-title">Wait</summary>
            <div class="drop-body">
                <div class="panel-block"
                     @onpointerdown="(e) => OnPalettePointerDown(e, typeof(WaitBlock), null)">
                    <svg width="90" height="90" viewBox="0 0 92 92">
                        <path d="M 1 1 L 15 1 L 15 15 L 30 1 L 91 1 L 91 75 L 30 75 L 15 91 L 15 75 L 1 75 Z"
                              fill="@PaletteGray" stroke="#000000" stroke-width="1" />
                        <text x="46" y="45" text-anchor="middle" font-size="14" font-weight="bold">Wait</text>
                    </svg>
                </div>
            </div>
        </details>
    </div>

    <div class="stage" @ref="stageRef"
         @onpointermove="OnStagePointerMove"
         @onpointerup="OnStagePointerUp"
         @onpointercancel="OnStagePointerUp">

        @if (hoverActive)
        {
            <div class="ghost"
                 style="left:@($"{hoverX}px"); top:@($"{hoverY}px");">
                <svg width="90" height="90" viewBox="0 0 92 92">
                    <path d="M 1 1 L 15 1 L 15 15 L 30 1 L 91 1 L 91 75 L 30 75 L 15 91 L 15 75 L 1 75 Z"
                          fill="transparent" stroke="#000000" stroke-width="3" />
                </svg>
            </div>
        }

        @foreach (var b in blocks)
        {
            <GridRunner.Components.CodeBlock block="b" onPointerDown="OnBlockPointerDown" isExecuting="@(currentlyExecutingBlockId == b.Id)" />
        }
    </div>

    <div class="grid-wrapper">
        @{
            var (prefix, _, cellSizePx, cols) = GetGridRenderInfo();
            var (exitRow, exitCol) = GetExitRowCol(prefix);
            string exitClass = ExitSide.HasValue ? $"exit-{ExitSide.Value}" : "";

            string gridStyle =
            $"--cell-size:{cellSizePx}px;" +
            $"--cols:{cols};" +
            $"--exit-row:{exitRow};" +
            $"--exit-col:{exitCol};" +
            $"display:grid; grid-template-columns:repeat({cols},{cellSizePx}px);" +
            $"grid-auto-rows:{cellSizePx}px;";
        }

        <div class="grid-container @GridCssClass @exitClass" style="@gridStyle">
            @RenderGrid()
        </div>
    </div>
</div>

@code {
    // Element reference for drag-and-drop
    private ElementReference stageRef;

    // UI State
    private string StatusMessage = "";

    // Properties delegated to services
    private string SelectedDifficulty
    {
        get => LevelLoader.SelectedDifficulty;
        set => LevelLoader.SelectedDifficulty = value;
    }

    private List<Vehicle> Vehicles => LevelLoader.Vehicles;
    private char? ExitSide => LevelLoader.ExitSide;
    private string? ExitCellKey => LevelLoader.ExitCellKey;
    private int? CurrentLevelIndex => LevelLoader.CurrentLevelIndex;

    private bool GameWon => VehicleMovement.GameWon;
    private bool HasSelection => VehicleMovement.HasSelection;
    private string SelectedVehicleDisplay => VehicleMovement.GetSelectedVehicleDisplay();

    private List<Block> blocks => BlockExecution.Blocks;
    private int? currentlyExecutingBlockId => BlockExecution.CurrentlyExecutingBlockId;
    private bool IsExecuting => BlockExecution.IsExecuting;
    private bool hoverActive => BlockExecution.HoverActive;
    private double hoverX => BlockExecution.HoverX;
    private double hoverY => BlockExecution.HoverY;

    private const string PaletteGray = "#DDDDDD";

    private string GridCssClass => SelectedDifficulty switch
    {
        "Easy" => "easy",
        "Medium" => "medium",
        "Hard" => "hard",
        _ => "easy"
    };

    // Event Handlers - Level Management
    private void PlayRandomUnplayed()
    {
        LevelLoader.PlayRandomUnplayed();
        BlockExecution.GenerateStartBlocksForVehicles();
        StatusMessage = LevelLoader.LastStatusMessage;
    }

    private void PlayAgain()
    {
        if (!string.IsNullOrWhiteSpace(LevelLoader.LastLevelLine))
        {
            LevelLoader.LoadLevelLine(LevelLoader.LastLevelLine!);
            BlockExecution.GenerateStartBlocksForVehicles();
        }
        else
        {
            ClearLevel();
        }
        StatusMessage = LevelLoader.LastStatusMessage;
    }

    private void PlayNextLevel()
    {
        PlayRandomUnplayed();
    }

    private void ClearLevel()
    {
        LevelLoader.ClearLevel();
        BlockExecution.ClearBlocks();
        VehicleMovement.Reset();
        StatusMessage = "Cleared.";
    }

    // Event Handlers - Block System
    private async void OnBlockPointerDown(PointerEventArgs e, int id)
    {
        await BlockExecution.OnBlockPointerDown(e, id, stageRef);
    }

    private void OnStagePointerMove(PointerEventArgs e)
    {
        BlockExecution.OnStagePointerMove(e);
    }

    private void OnStagePointerUp(PointerEventArgs e)
    {
        BlockExecution.OnStagePointerUp(e);
    }

    private async Task OnPalettePointerDown(PointerEventArgs e, Type blockToInstantiate, Enum? action)
    {
        await BlockExecution.OnPalettePointerDown(e, blockToInstantiate, action, stageRef);
    }

    private async Task RunBlockStacks()
    {
        StatusMessage = await BlockExecution.RunBlockStacks();
        StateHasChanged();
    }

    // Helper Methods
    private (string Prefix, List<string> Cells, int CellSizePx, int Cols) GetGridRenderInfo()
    {
        return LevelLoader.GetGridRenderInfo();
    }

    private (int rowIndex, int colIndex) GetExitRowCol(string prefix)
    {
        return LevelLoader.GetExitRowCol(prefix);
    }

    // Render Grid - UI-specific logic
    private RenderFragment RenderGrid() => builder =>
    {
        var (prefix, cells, _, _) = GetGridRenderInfo();
        int seq = 0;

        var cellToVehicleIndex = new Dictionary<string, int>();
        for (int i = 0; i < Vehicles.Count; i++)
            foreach (var key in Vehicles[i].Cells)
                cellToVehicleIndex[key] = i;

        foreach (var cell in cells)
        {
            var key = prefix + cell;

            bool hasVehicle = cellToVehicleIndex.TryGetValue(key, out var vIndex);
            Vehicle? vehicle = hasVehicle ? Vehicles[vIndex] : null;

            bool isExit = (ExitCellKey == key);
            bool isSelected = HasSelection && hasVehicle && vIndex == VehicleMovement.SelectedVehicleIndex!.Value;

            string classes = "cell";
            if (vehicle != null) classes += " occupied " + vehicle.CssClass;
            if (isExit && ExitSide.HasValue) classes += " exit exit-" + ExitSide.Value;
            if (isSelected) classes += " selected";

            builder.OpenElement(seq++, "div");
            builder.AddAttribute(seq++, "class", classes);
            builder.AddAttribute(seq++, "id", key);
            builder.AddContent(seq++, cell);

            if (vehicle != null && vehicle.Cells.Count > 0 && vehicle.Cells[0] == key)
            {
                builder.OpenElement(seq++, "div");
                builder.AddAttribute(seq++, "class", "veh-label");
                builder.AddContent(seq++, vehicle.Type.ToString());
                builder.CloseElement();
            }

            builder.CloseElement();
        }
    };
}
<script>
    window.blockDrag = {
        rect: (el) => {
            const r = el.getBoundingClientRect();
            return { left: r.left, top: r.top };
        }
    };
</script>

<style>
    .controls {
        margin-bottom: 14px;
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
    }

    .selected-info {
        margin-left: 8px;
        font-weight: 600;
    }

    .status {
        margin-bottom: 10px;
        font-weight: 600;
    }

    .status.win {
        font-size: 18px;
    }

    .main-layout {
        display: flex;
        gap: 12px;
        margin-bottom: 20px;
    }

    .panel {
        width: 130px;
        border: 1px solid #ccc;
        background: #f7f7f7;
        padding: 4px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        user-select: none;
        touch-action: none;
        height: 50vh;
        overflow-y: auto;
    }

    .drop {
        margin-bottom: 8px;
    }

    .drop-title {
        font-weight: 600;
        padding: 4px;
        cursor: pointer;
        background: #e0e0e0;
        border-radius: 4px;
    }

    .drop-body {
        padding-top: 4px;
    }

    .panel-block {
        display: flex;
        align-items: center;
        justify-content: flex-start;
        padding: 6px;
        border-radius: 8px;
        cursor: grab;
        user-select: none;
        margin-bottom: 4px;
    }

    .panel-block:active {
        cursor: grabbing;
    }

    .stage {
        position: relative;
        height: 50vh;
        width: 400px;
        border: 1px solid #ccc;
        user-select: none;
        touch-action: none;
        overflow: visible;
        background: #fafafa;
    }

    .ghost {
        position: absolute;
        pointer-events: none;
        opacity: 0.9;
        z-index: 0;
    }

    .grid-wrapper {
        display: flex;
        align-items: flex-start;
    }

    .grid-container {
        width: fit-content;
        position: relative;
        gap: 0;
        border: 1px solid #000;
        background: white;
        box-sizing: border-box;
    }

    .cell {
        border: 1px solid #333;
        background-color: #a1e9ed;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        position: relative;
        user-select: none;
        box-sizing: border-box;
        cursor: pointer;
    }

    .cell.selected {
        outline: 4px solid rgba(0,0,0,0.55);
        outline-offset: -4px;
    }

    .occupied.veh-red { background-color: #ff6b6b; }
    .occupied.veh-green { background-color: #5fe37a; }
    .occupied.veh-blue { background-color: #6ea8fe; }
    .occupied.veh-yellow { background-color: #ffe066; }

    .veh-label {
        position: absolute;
        bottom: 3px;
        right: 5px;
        font-size: 12px;
        opacity: 0.9;
        pointer-events: none;
    }

    .cell.exit.exit-A { border-left-color: white; }
    .cell.exit.exit-B { border-top-color: white; }
    .cell.exit.exit-C { border-right-color: white; }
    .cell.exit.exit-D { border-bottom-color: white; }

    .grid-container.exit-B::before,
    .grid-container.exit-D::before {
        content: "";
        position: absolute;
        left: calc(var(--exit-col) * var(--cell-size));
        width: var(--cell-size);
        height: 4px;
        background: white;
        pointer-events: none;
        z-index: 10;
    }

    .grid-container.exit-B::before { top: -2px; }
    .grid-container.exit-D::before { bottom: -2px; }

    .grid-container.exit-A::before,
    .grid-container.exit-C::before {
        content: "";
        position: absolute;
        top: calc(var(--exit-row) * var(--cell-size));
        height: var(--cell-size);
        width: 4px;
        background: white;
        pointer-events: none;
        z-index: 10;
    }

    .grid-container.exit-A::before { left: -2px; }
    .grid-container.exit-C::before { right: -2px; }
</style>
